{"timestamp": "2025-09-20T14:42:30.951398", "agent_id": "investigator-143821-acd127", "finding_type": "insight", "severity": "medium", "message": "plc_manager is only invoked by step_flow; recipe_flow orchestrates DB/state and never touches PLC directly.", "data": {"where": ["src/step_flow/valve_step.py:62-86", "src/step_flow/purge_step.py:58-76", "src/step_flow/parameter_step.py:70-86"], "notes": "All hardware actions (valve, purge, parameter write) go through step_flow.* using plc_manager.plc.<method>. This isolates hardware side-effects to step handlers."}}
{"timestamp": "2025-09-20T14:42:58.787912", "agent_id": "investigator-143821-acd127", "finding_type": "recommendation", "severity": "high", "message": "Add step-scoped structured logs and a dry-run/trace switch without refactors.", "data": {"config_flags": {"add_to": "src/config.py: after PLC_CONFIG", "flags": [{"name": "TRACE_STEPS", "env": "TRACE_STEPS", "default": "false", "desc": "Emit structured step start/end + PLC IO details."}, {"name": "DRY_RUN_STEPS", "env": "DRY_RUN_STEPS", "default": "false", "desc": "Skip real PLC IO; simulate timings; still update DB state."}, {"name": "VERIFY_PARAM_WRITES", "env": "VERIFY_PARAM_WRITES", "default": "false", "desc": "Read back parameter after write and log actual vs setpoint."}]}, "structured_log_helper": {"add_to": "src/log_setup.py", "function": "def log_event(event:str, **fields): logger.info(f\"EVT {event} | \"+json.dumps(fields, default=str))", "notes": "Keeps default formatter; no dependency on structlog."}, "insertion_points": [{"file": "src/step_flow/executor.py", "lines": "11-26, 34-66", "add": "Capture step_id, sequence_number, parent_step_id; time.perf_counter(); log_event('step_start', process_id, step_id, name, type, seq, parent_id, params=redacted_keys(step['parameters'])). After successful await execute_*: elapsed_ms, log_event('step_end', ..., elapsed_ms). On except: log_event('step_error', ..., err=str(e))."}, {"file": "src/step_flow/valve_step.py", "lines": "61-86", "add": "Before PLC call: if DRY_RUN_STEPS: await asyncio.sleep(duration_ms/1000); log_event('valve_dry_run', process_id, step_id, valve_number, duration_ms); return. Else: start_ts; success = await plc_manager.plc.control_valve(...); elapsed_ms; log_event('valve_io', process_id, step_id, valve_number, duration_ms, success, elapsed_ms)."}, {"file": "src/step_flow/purge_step.py", "lines": "61-80", "add": "Same dry-run gate + log_event('purge_io', process_id, step_id, duration_ms, success, elapsed_ms)."}, {"file": "src/step_flow/parameter_step.py", "lines": "25-50 and 70-100", "add": "At execute_parameter_step: log_event('param_step', process_id, step_id=step['id'], parameter_id, target=parameter_value). In set_parameter_value(): before write -> log_event('param_write_attempt', parameter_id, value, min=min_value, max=max_value); DRY_RUN_STEPS short-circuit: update DB, log_event('param_dry_run', ...); else do write then if VERIFY_PARAM_WRITES: after=await plc_manager.read_parameter(parameter_id); log_event('param_write_result', parameter_id, set=value, readback=after, diff=(after-value))."}], "recipe_timing": {"file": "src/recipe_flow/executor.py", "lines": "12-21, 63-121", "add": "At start: log_event('recipe_start', process_id, totals={'steps': total_steps, 'cycles': total_cycles}); around top-level step loop, measure per-step elapsed and log at end; after complete_recipe(): log_event('recipe_end', process_id)."}, "note_on_surfaces": "All changes are additive and localized; no DB schema changes; step IDs stay in logs (not DB)."}}
{"timestamp": "2025-09-20T14:43:06.572322", "agent_id": "investigator-143821-acd127", "finding_type": "recommendation", "severity": "medium", "message": "Prefer plc_manager methods over direct plc attribute access in step_flow to centralize trace/dry-run hooks.", "data": {"current_calls": [{"file": "src/step_flow/valve_step.py", "calls": ["plc = plc_manager.plc", "await plc.control_valve(...)"]}, {"file": "src/step_flow/purge_step.py", "calls": ["plc = plc_manager.plc", "await plc.execute_purge(...)"]}, {"file": "src/step_flow/parameter_step.py", "calls": ["plc = plc_manager.plc", "await plc.write_parameter(...)"]}], "minimal_change": "Replace with await plc_manager.control_valve(...), await plc_manager.execute_purge(...), await plc_manager.write_parameter(...). Then implement DRY_RUN_STEPS and TRACE_STEPS in PLCManager to short-circuit/log once."}}

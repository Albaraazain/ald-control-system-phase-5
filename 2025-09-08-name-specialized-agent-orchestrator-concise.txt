‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ
‚îÇ ‚úª Welcome to Claude Code!                                 ‚îÇ
‚îÇ                                                           ‚îÇ
‚îÇ   /help for help, /status for your current setup          ‚îÇ
‚îÇ                                                           ‚îÇ
‚îÇ   cwd: /home/albaraa/Projects/ald-control-system-phase-5  ‚îÇ
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ

> --- name: Specialized Agent Orchestrator - Concise description: MANDATORY headless Claude orchestration - NO Task tool, NO built-in agents, ONLY headless --- # üö® CRITICAL: YOU MUST USE 
  HEADLESS CLAUDE ONLY! üö® ## ‚õî ABSOLUTE RULE #1: NEVER USE Task TOOL - ALWAYS HEADLESS CLAUDE ### ‚ùå VIOLATIONS =

  pasted

  i like this orchestrator but problem is sometimes it spirals out of control, and keeps launching agents inside of agents how can we fix that,. like is there a way to track all the agents 
  deployed within a workspace, so that each subagent deployed it checks all the agents deployed within this workspace. do you know what i mean


  Devised strategy to prevent recursive agent spawning.



  I understand exactly what you mean! The problem is agents spawning agents recursively without awareness of what's already running. Let's fix this with a centralized agent registry and spawn 
  control rules. Here's an enhanced orchestrator that prevents spiraling:

  Controlled Agent Orchestrator - Anti-Spiral Edition
  Document 

  Engineered robust system to prevent uncontrolled agent spawning.


  The key insight here is that you need centralized spawn control and visibility into the agent hierarchy. I've created an enhanced orchestrator that prevents spiraling through:

  Core Solutions:
  Agent Registry (AGENT_REGISTRY.json) - A single source of truth tracking:
  All deployed agents
  Their parent-child relationships
  Current status (running/completed/killed)
  Depth in the hierarchy
  Spawn Rules (SPAWN_RULES.json) - Explicit permissions:
  Only the orchestrator can spawn primary agents
  Primary agents can spawn ONE type of helper each
  Helpers cannot spawn anything
  This creates a controlled tree, not a spiral
  Hard Limits:
  Max depth: 3 levels (orchestrator ‚Üí primary ‚Üí helper ‚Üí STOP)
  Max agents: 10 total per task
  Max simultaneous: 5 running at once
  Duplicate Prevention: Before spawning, check if that agent type is already running
  Emergency Brake: If more than 5 agents run simultaneously, the monitor kills the newest ones
  The magic is in the deploy_agent_safely() function that checks the registry before EVERY spawn, enforcing the rules. Agents can't spawn directly anymore - they must go through this controlled
   function.

  This way, you maintain the power of multi-agent orchestration while preventing the recursive spiral that was causing chaos. The registry gives you complete visibility into what's running at 
  any moment.

  Alright any other improvemenets that mirrors real life and how can agents perform tasks properly and completely


  Mapped real-world organizational patterns to enhance agent orchestration.


  Excellent question! Let's make this orchestrator mirror real-world team dynamics with proper task completion, quality gates, and accountability. Here's an enhanced version with real-life work
   patterns:

  Realistic Agent Orchestrator - Enterprise Team Edition
  Document 

  Crafted comprehensive system mirroring real-world work patterns.

  Key Real-World Improvements I've Added:
  1. Definition of Done (Like Real Teams)
  Acceptance criteria BEFORE work starts
  Measurable success metrics
  Quality gates that must pass
  2. Time Management (Like Real Deadlines)
  Timeboxed execution
  Escalation when running late
  Different interventions based on progress
  3. The Stuck Detection (Like Real Employees)
  Agents that detect when they're stuck
  Automatic escalation to senior agents
  Helper specialists for specific blockers
  4. Knowledge Base (Organizational Learning)
  Every failure documented
  Searchable lessons learned
  Future agents check past attempts first
  5. Review Process (Like Code Review)
  Peer review before marking complete
  Specific reviewer agents
  Can reject and rollback bad work
  6. Progress Transparency (Like Standups)
  Regular progress updates
  Current task visibility
  Confidence scores
  Additional Advanced Patterns You Could Add:
  The Pair Programming Pattern
  python
  # Two agents work together, one codes, one reviews in real-time
  def deploy_pair_programmers(workspace, task):
      driver_prompt = "You are the driver. Write code while explaining your thinking..."
      navigator_prompt = "You are the navigator. Review the driver's code and suggest improvements..."
      # They alternate roles every 15 minutes
  The Swarming Pattern (Crisis Response)
  python
  # When critical issue detected, multiple specialists attack simultaneously
  def deploy_swarm(workspace, critical_issue):
      # Deploy 5 specialists at once, each taking a different angle
      aspects = ["performance", "security", "data_integrity", "user_experience", "scalability"]
      for aspect in aspects:
          deploy_specialist(workspace, aspect, critical_issue)
  The Apprentice Pattern (Learning System)
  python
  # Junior agent watches senior agent, then tries similar task
  def train_junior_agent(workspace, task):
      # First, senior does the task while documenting
      senior = deploy_agent("senior_expert", task, document_mode=True)
      
      # Then junior attempts similar task using senior's documentation
      junior = deploy_agent("junior_learner", similar_task, 
                           reference=senior.documentation)
  The Shift Handover Pattern
  python
  # Like real 24/7 operations with shift changes
  def shift_handover(workspace, outgoing_agent, incoming_agent):
      # Outgoing agent writes detailed handover
      # Incoming agent reads handover and continues work
      # Overlap period where both are active for knowledge transfer
  The Most Critical Success Factors:
  ALWAYS have rollback points - Every agent creates a git commit before starting
  Monitor confidence scores - Agents self-report confidence, intervene when low
  Use the right specialist - Don't use generic agents, use specialized ones
  Document everything - Future agents learn from past attempts
  Set time limits - Prevent infinite loops with hard deadlines
  Example: Realistic Task Execution
  python
  # User says: "Fix the performance issue with the measurement screen"

  # 1. Create ticket with clear criteria
  ticket = create_task_ticket(
      workspace,
      "Fix measurement screen performance - should load in <2 seconds"
  )

  # 2. Deploy investigator first (don't jump to solutions)
  investigator = deploy_agent("performance_investigator", 
                             "Profile and identify bottlenecks")

  # 3. Based on findings, deploy the RIGHT specialist
  if "database" in findings:
      deploy_agent("database_optimizer", "Optimize the slow queries identified")
  elif "frontend" in findings:
      deploy_agent("react_optimizer", "Fix rendering performance issues")

  # 4. Always review before accepting
  reviewer = deploy_agent("performance_reviewer", 
                         "Verify performance actually improved")

  # 5. Document learnings
  update_knowledge_base(workspace, ticket, 
                       "Learned that N+1 queries were the issue")
  This approach ensures agents:

  Know exactly what success looks like
  Don't work in isolation
  Learn from each other
  Have safety nets (rollback, review, escalation)
  Complete tasks fully (not just partially)
  The key insight: Treat agents like real team members with accountability, communication, and support systems!

  alright nice i like that can we compliment this system with scripts in bash or python in which the agents or the main orchestrator system can use, like for deploying agents creating the main 
  workspace, that way its controlled, and we can deploy and maintain with ids and stuff. i dont know if you understood what i mean, also while the agents are executing they  can make 
  update_progress command that will append maybe the progress to the json file in teh agent workspace.


  Engineered standardized CLI toolkit for agent deployment and tracking.



  Absolutely! You're thinking like a true systems architect - let's create a standardized CLI toolkit that both the orchestrator and agents can use. This gives us controlled, consistent 
  operations with proper ID management. Here's a comprehensive script system:

  Agent Management CLI Toolkit - Bash Scripts
  Code 

  Plotted Python script to demonstrate orchestrator's controlled system.

  Perfect! Now let me create the Python orchestrator that uses these CLI commands:

  Python Agent Orchestrator - Using CLI Toolkit
  Code 

  Engineered comprehensive agent deployment and tracking system.



  Perfect! I've created a complete CLI toolkit system that provides exactly what you wanted:

  üéØ What This System Gives You:
  1. Standardized CLI Commands (Bash Scripts)
  agent-ctl init - Initialize workspace with proper structure
  agent-ctl deploy - Deploy agents with ID tracking
  agent-ctl status - Check task/agent status
  agent-ctl monitor - Live monitoring with intervention
  agent-ctl kill - Controlled termination
  agent-ctl report - Generate reports
  2. Agent Helper Commands
  Agents can call these simple commands instead of writing raw JSON:

  update-progress 50 "Halfway done" - Updates progress
  escalate "Need database access" - Escalates issues
  write-finding "root_cause" "N+1 queries" - Documents findings
  read-context - Reads task context
  create-rollback "Before major change" - Creates restore points
  check-quality - Runs quality checks
  3. Python Orchestrator
  Uses the CLI tools for controlled management with:

  Anti-spiral protection
  Automatic intervention for stuck agents
  Parallel and sequential patterns
  Quality gates and iterations
  Deadline management
  üöÄ How It Works:
  Installation:
  bash
  # Run the installation script to set up the toolkit
  bash setup_agent_toolkit.sh

  # This creates:
  .agent-workspace/
  ‚îú‚îÄ‚îÄ scripts/       # All the CLI scripts
  ‚îú‚îÄ‚îÄ bin/          # The main agent-ctl command
  ‚îî‚îÄ‚îÄ templates/    # Agent templates
  Example Agent Using Commands:
  bash
  # Inside an agent, instead of complex JSON manipulation:

  # Update progress (agent just calls this)
  update-progress 25 "Starting database analysis"

  # Document a finding
  write-finding "slow_query" "SELECT * FROM measurements takes 5s"

  # Create rollback point before changes
  create-rollback "Before schema modification"

  # Update progress again
  update-progress 75 "Schema updated, testing"

  # If stuck, escalate
  escalate "Cannot connect to staging database"

  # Final update
  update-progress 100 "Task completed successfully"
  Orchestrator Usage:
  python
  orchestrator = AgentOrchestrator()

  # Create task (returns TASK-20241221-123456-abc123)
  task_id = orchestrator.create_task("Fix performance issues")

  # Deploy agent (controlled with IDs)
  agent_id = orchestrator.deploy_agent(
      task_id,
      "database_detective",
      "Find the slow queries"
  )
  # Returns: database_detective-143022-a1b2c3

  # Orchestrator monitors automatically and intervenes if needed
  üîë Key Benefits:
  Controlled Deployment: Every agent gets unique IDs, tracked in registry
  Standardized Operations: No raw bash/JSON - just simple commands
  Progress Tracking: Agents call update-progress, orchestrator monitors
  Anti-Spiral: Registry prevents recursive spawning
  Intervention System: Automatic help for stuck agents
  Rollback Safety: Every agent can create restore points
  Quality Gates: Built-in quality checking
  üìä The Registry System:
  Each task has an AGENT_REGISTRY.json that tracks:

  json
  {
    "task_id": "TASK-20241221-143022-abc123",
    "agents": [
      {
        "id": "investigator-143022-a1b2c3",
        "type": "investigator",
        "bash_id": "bash_xyz789",
        "status": "running",
        "progress": 75,
        "parent": "orchestrator",
        "depth": 1
      }
    ],
    "total_spawned": 3,
    "active_count": 2,
    "max_agents": 10,
    "max_depth": 3
  }
  üéÆ Usage Examples:
  From Orchestrator:
  python
  # Pattern 1: Investigation ‚Üí Fix ‚Üí Review
  task_id = orchestrator.orchestrate_investigation_fix_pattern(
      "Users see empty data despite DB having records"
  )

  # Pattern 2: Parallel Analysis
  task_id = orchestrator.orchestrate_parallel_analysis(
      "Optimize app performance",
      aspects=["database", "frontend", "api", "caching"]
  )

  # Pattern 3: Iterative Improvement with Quality Gates
  task_id = orchestrator.orchestrate_iterative_improvement(
      "Refactor auth system",
      max_iterations=3  # Keep improving until quality > 80%
  )
  From Agent's Perspective:
  bash
  # Agent receives its ID and workspace via environment
  AGENT_ID="database_detective-143022-a1b2c3"
  WORKSPACE=".agent-workspace/TASK-20241221-143022"

  # Read what to do
  read-context

  # Do work and update progress
  update-progress 10 "Connected to database"
  # ... do analysis ...
  update-progress 40 "Found 3 slow queries"
  # ... write fixes ...
  update-progress 80 "Optimizations applied"

  # Document findings
  write-finding "slow_queries" "3 N+1 queries in measurements"
  write-finding "solution" "Added indexes and eager loading"

  # Quality check before completing
  if check-quality; then
      update-progress 100 "All quality checks passed"
  else
      escalate "Quality checks failing, need help"
  fi
  This system gives you complete control with standardized operations that both the orchestrator and agents can use. No more raw bash commands or manual JSON manipulation - just clean, 
  trackable, ID-based operations! üéØ

  The beauty is that agents don't need to know the implementation details - they just call simple commands like update-progress and the system handles everything else!

  alright but i dont know where to create these files or how


  Devised comprehensive setup guide for file creation steps.


  Excellent point! Let me give you exact step-by-step instructions on how to set up this entire system:

  Complete Setup Instructions - Step by Step
  Document 

  Crafted detailed, step-by-step guide for file creation.




  Perfect! I've created complete step-by-step instructions that show you:

  üìç Where to Create Files:
  Create a new project folder anywhere you want (e.g., agent-orchestrator)
  All files go in this folder - it becomes your project root
  The installer creates the .agent-workspace/ subdirectory automatically
  üéØ How to Set It Up:
  The Easy Way (Copy-Paste):
  Open your terminal
  Copy and paste these commands one by one:
  bash
  # Step 1: Create project folder
  mkdir agent-orchestrator
  cd agent-orchestrator

  # Step 2: Create the installer (copy the whole block)
  cat > install_toolkit.sh << 'EOF'
  [paste the installer script content from above]
  EOF

  # Step 3: Run installer
  chmod +x install_toolkit.sh
  ./install_toolkit.sh

  # Step 4: Set PATH
  export PATH="$PWD/.agent-workspace/bin:$PATH"

  # Step 5: Test it!
  agent-ctl init "My first task"
  ‚úÖ What You Get:
  After running these commands, you'll have a fully working system where:

  agent-ctl init "task" creates a new task with workspace
  agent-ctl deploy deploys agents with tracking
  agent-ctl status TASK-ID shows what's running
  All data is stored in organized JSON files
  ÔøΩÔøΩ Test Without Claude First:
  The scripts work standalone! You can test the entire flow:

  bash
  # Create a task
  agent-ctl init "Test task"
  # Returns: TASK-20241221-143022-abc123

  # Deploy a fake agent (won't actually run Claude)
  agent-ctl deploy "test_agent" "TASK-20241221-143022-abc123" "Test prompt"

  # Update its progress manually
  agent-ctl update "test_agent-143022-abc123" 50 "Halfway done"

  # Check status
  agent-ctl status "TASK-20241221-143022-abc123"
  üìù Key Points:
  You create ONE main folder for the project
  Run ONE installer script that creates everything else
  Use simple commands instead of complex scripts
  Everything is tracked with IDs and JSON files
  The beauty is you don't need to manually create 20 different files - the installer script creates them all for you! Just copy, paste, and run! üöÄ



  but how will it trach 


  [O   /    Step 2: Create the Installation Script
  Create the main installation script that sets everything up:
  bash# Create the installation script
  cat > install_toolkit.sh << 'EOF'
  #!/bin/bash

  echo "üöÄ Installing Agent Orchestration Toolkit..."

  # Create base directories
  mkdir -p .agent-workspace/{scripts,templates,bin}

  # Create the main control script
  cat > .agent-workspace/bin/agent-ctl << 'MAIN_CMD'
  #!/bin/bash
  AGENT_BASE_DIR=".agent-workspace"
  COMMAND=$1
  shift

  case $COMMAND in
      init|deploy|status|update|monitor|kill|review|report)
          $AGENT_BASE_DIR/scripts/${COMMAND}.sh "$@"
          ;;
      *)
          echo "Usage: agent-ctl {init|deploy|status|update|monitor|kill|review|report} [options]"
          exit 1
          ;;
  esac
  MAIN_CMD

  chmod +x .agent-workspace/bin/agent-ctl

  # Add to PATH for current session
  export PATH="$PWD/.agent-workspace/bin:$PATH"
  echo "‚úÖ Main control script created"

  # Now create each individual script
  echo "üìù Creating individual scripts..."

  # === INIT SCRIPT ===
  cat > .agent-workspace/scripts/init.sh << 'SCRIPT'
  #!/bin/bash
  AGENT_BASE_DIR=".agent-workspace"
  TASK_DESC="${1:-No description provided}"
  PRIORITY="${2:-P2}"

  TASK_ID="TASK-$(date +%Y%m%d-%H%M%S)-$(head -c 4 /dev/urandom | xxd -p)"
  WORKSPACE="${AGENT_BASE_DIR}/${TASK_ID}"

  echo "üìÇ Initializing workspace: ${WORKSPACE}"
  mkdir -p "${WORKSPACE}"/{context,progress,handoffs,tickets,reviews,rollbacks,knowledge,metrics,escalations,standups}

  # Create registry
  cat > "${WORKSPACE}/AGENT_REGISTRY.json" << JSON
  {
    "task_id": "${TASK_ID}",
    "task_description": "${TASK_DESC}",
    "created_at": "$(date -Iseconds)",
    "workspace": "${WORKSPACE}",
    "status": "INITIALIZED",
    "agents": [],
    "max_agents": 10,
    "max_depth": 3,
    "total_spawned": 0,
    "active_count": 0
  }
  JSON

  echo "‚úÖ Task initialized: ${TASK_ID}"
  echo "TASK_ID=${TASK_ID}"
  SCRIPT

  # === DEPLOY SCRIPT ===
  cat > .agent-workspace/scripts/deploy.sh << 'SCRIPT'
  #!/bin/bash
  AGENT_BASE_DIR=".agent-workspace"
  AGENT_TYPE="${1:?Error: Agent type required}"
  TASK_ID="${2:?Error: Task ID required}"
  TASK_PROMPT="${3:?Error: Task prompt required}"

  WORKSPACE="${AGENT_BASE_DIR}/${TASK_ID}"
  AGENT_ID="${AGENT_TYPE}-$(date +%H%M%S)-$(head -c 3 /dev/urandom | xxd -p)"

  echo "ü§ñ Deploying agent: ${AGENT_ID}"

  # Update registry (simplified version)
  if [ -f "${WORKSPACE}/AGENT_REGISTRY.json" ]; then
      # Add agent to registry (using python for JSON manipulation)
      python3 -c "
  import json
  with open('${WORKSPACE}/AGENT_REGISTRY.json', 'r') as f:
      registry = json.load(f)
  registry['agents'].append({
      'id': '${AGENT_ID}',
      'type': '${AGENT_TYPE}',
      'status': 'running',
      'progress': 0,
      'started_at': '$(date -Iseconds)'
  })
  registry['total_spawned'] += 1
  registry['active_count'] += 1
  with open('${WORKSPACE}/AGENT_REGISTRY.json', 'w') as f:
      json.dump(registry, f, indent=2)
  "
  fi

  # Here you would deploy via Claude
  echo "Would deploy: claude --dangerously-skip-permissions -p \"${TASK_PROMPT}\""
  echo "‚úÖ Agent deployed: ${AGENT_ID}"
  echo "${AGENT_ID}"
  SCRIPT

  # === STATUS SCRIPT ===
  cat > .agent-workspace/scripts/status.sh << 'SCRIPT'
  #!/bin/bash
  AGENT_BASE_DIR=".agent-workspace"
  TASK_ID="${1:?Error: Task ID required}"
  WORKSPACE="${AGENT_BASE_DIR}/${TASK_ID}"

  if [ ! -f "${WORKSPACE}/AGENT_REGISTRY.json" ]; then
      echo "‚ùå Task ${TASK_ID} not found"
      exit 1
  fi

  echo "üìä TASK STATUS: ${TASK_ID}"
  echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
  python3 -c "
  import json
  with open('${WORKSPACE}/AGENT_REGISTRY.json', 'r') as f:
      registry = json.load(f)
  print(f\"Task: {registry['task_description']}\")
  print(f\"Status: {registry['status']}\")
  print(f\"Total Agents: {registry['total_spawned']}\")
  print(f\"Active: {registry['active_count']}\")
  print(\"\\nAgents:\")
  for agent in registry['agents']:
      print(f\"  ‚Ä¢ {agent['id']}: {agent['status']} ({agent['progress']}%)\")
  "
  SCRIPT

  # === UPDATE SCRIPT ===
  cat > .agent-workspace/scripts/update.sh << 'SCRIPT'
  #!/bin/bash
  AGENT_BASE_DIR=".agent-workspace"
  AGENT_ID="${1:?Error: Agent ID required}"
  PROGRESS="${2:?Error: Progress required}"
  MESSAGE="${3:-No message}"

  # Find workspace containing this agent
  WORKSPACE=$(grep -r "${AGENT_ID}" ${AGENT_BASE_DIR}/*/AGENT_REGISTRY.json 2>/dev/null | head -1 | cut -d: -f1 | xargs dirname)

  if [ -z "${WORKSPACE}" ]; then
      echo "‚ùå Agent ${AGENT_ID} not found"
      exit 1
  fi

  # Create progress file
  PROGRESS_FILE="${WORKSPACE}/progress/${AGENT_ID}_$(date +%s).json"
  cat > "${PROGRESS_FILE}" << JSON
  {
    "agent_id": "${AGENT_ID}",
    "timestamp": "$(date -Iseconds)",
    "progress": ${PROGRESS},
    "message": "${MESSAGE}"
  }
  JSON

  # Update registry
  python3 -c "
  import json
  with open('${WORKSPACE}/AGENT_REGISTRY.json', 'r') as f:
      registry = json.load(f)
  for agent in registry['agents']:
      if agent['id'] == '${AGENT_ID}':
          agent['progress'] = ${PROGRESS}
          agent['last_update'] = '$(date -Iseconds)'
          if ${PROGRESS} == 100:
              agent['status'] = 'completed'
              registry['active_count'] -= 1
  with open('${WORKSPACE}/AGENT_REGISTRY.json', 'w') as f:
      json.dump(registry, f, indent=2)
  "

  echo "‚úÖ Progress updated: ${PROGRESS}% - ${MESSAGE}"
  SCRIPT

  # === MONITOR SCRIPT ===
  cat > .agent-workspace/scripts/monitor.sh << 'SCRIPT'
  #!/bin/bash
  AGENT_BASE_DIR=".agent-workspace"
  TASK_ID="${1:?Error: Task ID required}"

  echo "üëÅÔ∏è Monitoring ${TASK_ID} (Press Ctrl+C to stop)"
  while true; do
      clear
      .agent-workspace/scripts/status.sh "${TASK_ID}"
      sleep 5
  done
  SCRIPT

  # === KILL SCRIPT ===
  cat > .agent-workspace/scripts/kill.sh << 'SCRIPT'
  #!/bin/bash
  echo "ÔøΩÔøΩ Kill agent (simplified version)"
  echo "In production, this would terminate the agent process"
  SCRIPT

  # === REVIEW SCRIPT ===
  cat > .agent-workspace/scripts/review.sh << 'SCRIPT'
  #!/bin/bash
  echo "ÔøΩÔøΩ Review request (simplified version)"
  SCRIPT

  # === REPORT SCRIPT ===
  cat > .agent-workspace/scripts/report.sh << 'SCRIPT'
  #!/bin/bash
  AGENT_BASE_DIR=".agent-workspace"
  TASK_ID="${1:?Error: Task ID required}"
  WORKSPACE="${AGENT_BASE_DIR}/${TASK_ID}"

  echo "üìä Report for ${TASK_ID}"
  echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
  if [ -f "${WORKSPACE}/AGENT_REGISTRY.json" ]; then
      cat "${WORKSPACE}/AGENT_REGISTRY.json"
  fi
  SCRIPT

  # Make all scripts executable
  chmod +x .agent-workspace/scripts/*.sh

  # Create helper commands for agents
  echo "üì¶ Creating agent helper commands..."

  # update-progress helper
  cat > .agent-workspace/bin/update-progress << 'HELPER'
  #!/bin/bash
  AGENT_ID="${AGENT_ID:-unknown}"
  .agent-workspace/bin/agent-ctl update "${AGENT_ID}" "$@"
  HELPER

  # escalate helper
  cat > .agent-workspace/bin/escalate << 'HELPER'
  #!/bin/bash
  AGENT_ID="${AGENT_ID:-unknown}"
  WORKSPACE="${WORKSPACE:-.}"
  echo "{\"agent_id\": \"${AGENT_ID}\", \"issue\": \"$1\", \"timestamp\": \"$(date -Iseconds)\"}" > "${WORKSPACE}/escalations/$(date +%s).json"
  echo "üö® Escalation recorded: $1"
  HELPER

  # write-finding helper
  cat > .agent-workspace/bin/write-finding << 'HELPER'
  #!/bin/bash
  KEY="${1:?Error: Key required}"
  VALUE="${2:?Error: Value required}"
  AGENT_ID="${AGENT_ID:-unknown}"
  WORKSPACE="${WORKSPACE:-.}"
  mkdir -p "${WORKSPACE}/findings"
  echo "{\"key\": \"${KEY}\", \"value\": \"${VALUE}\", \"agent_id\": \"${AGENT_ID}\"}" > "${WORKSPACE}/findings/${KEY}.json"
  echo "‚úÖ Finding recorded: ${KEY}"
  HELPER

  # read-context helper
  cat > .agent-workspace/bin/read-context << 'HELPER'
  #!/bin/bash
  WORKSPACE="${WORKSPACE:-.}"
  echo "üìñ Task Context:"
  if [ -f "${WORKSPACE}/AGENT_REGISTRY.json" ]; then
      python3 -c "import json; d=json.load(open('${WORKSPACE}/AGENT_REGISTRY.json')); print(d.get('task_description', 'No description'))"
  fi
  HELPER

  chmod +x .agent-workspace/bin/*

  echo "‚úÖ Installation complete!"
  echo ""
  echo "To use the toolkit:"
  echo "  export PATH=\"$PWD/.agent-workspace/bin:\$PATH\""
  echo ""
  echo "Available commands:"
  echo "  agent-ctl init \"task description\"     # Create new task"
  echo "  agent-ctl deploy <type> <task_id> \"prompt\"  # Deploy agent"
  echo "  agent-ctl status <task_id>            # Check status"
  echo "  agent-ctl monitor <task_id>           # Live monitoring"
  echo ""
  echo "Try it now:"
  echo "  agent-ctl init \"Test task\""
  EOF

  # Make installation script executable
  chmod +x install_toolkit.sh
  Step 3: Run the Installation
  bash# Run the installation script
  ./install_toolkit.sh

  # Add to PATH (important!)
  export PATH="$PWD/.agent-workspace/bin:$PATH"

  # Verify installation
  ls -la .agent-workspace/
  # Should show:
  # drwxr-xr-x  bin/
  # drwxr-xr-x  scripts/
  # drwxr-xr-x  templates/
  Step 4: Create the Python Orchestrator
  bash# Create the Python orchestrator
  cat > orchestrator.py << 'EOF'
  #!/usr/bin/env python3
  """
  Simple Agent Orchestrator
  """
  import subprocess
  import json
  import os
  import time
  from datetime import datetime

  class AgentOrchestrator:
      def __init__(self):
          self.base_dir = ".agent-workspace"
          
      def run_command(self, cmd):
          """Run a shell command"""
          result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
          return result.stdout.strip()
      
      def create_task(self, description):
          """Create a new task"""
          print(f"üìã Creating task: {description}")
          output = self.run_command(f"agent-ctl init '{description}'")
          
          # Extract task ID from output
          task_id = None
          for line in output.split('\n'):
              if line.startswith('TASK_ID='):
                  task_id = line.split('=')[1]
                  break
          
          print(f"‚úÖ Created task: {task_id}")
          return task_id
      
      def deploy_agent(self, task_id, agent_type, prompt):
          """Deploy an agent"""
          print(f"ü§ñ Deploying {agent_type}...")
          output = self.run_command(
              f"agent-ctl deploy '{agent_type}' '{task_id}' '{prompt}'"
          )
          
          # Get agent ID (last line of output)
          agent_id = output.split('\n')[-1]
          print(f"‚úÖ Deployed: {agent_id}")
          return agent_id
      
      def get_status(self, task_id):
          """Get task status"""
          return self.run_command(f"agent-ctl status '{task_id}'")
      
      def update_progress(self, agent_id, progress, message):
          """Update agent progress"""
          return self.run_command(
              f"agent-ctl update '{agent_id}' {progress} '{message}'"
          )
      
      def monitor_task(self, task_id, duration=30):
          """Monitor a task for a duration"""
          print(f"üëÅÔ∏è Monitoring {task_id} for {duration} seconds...")
          start = time.time()
          while time.time() - start < duration:
              print("\n" + "="*50)
              print(self.get_status(task_id))
              time.sleep(5)

  # Example usage
  if __name__ == "__main__":
      orchestrator = AgentOrchestrator()
      
      # Create a task
      task_id = orchestrator.create_task("Fix database performance issues")
      
      # Deploy some agents
      investigator = orchestrator.deploy_agent(
          task_id,
          "investigator",
          "Investigate the database performance issues"
      )
      
      # Simulate progress updates
      orchestrator.update_progress(investigator, 25, "Starting investigation")
      time.sleep(2)
      orchestrator.update_progress(investigator, 50, "Found slow queries")
      time.sleep(2)
      orchestrator.update_progress(investigator, 100, "Investigation complete")
      
      # Check final status
      print("\nFinal Status:")
      print(orchestrator.get_status(task_id))
  EOF

  # Make it executable
  chmod +x orchestrator.py
  Step 5: Test the System
  bash# Test 1: Basic CLI commands
  agent-ctl init "Test task to verify setup"
  # Output: Task initialized: TASK-20241221-143022-abc123

  # Test 2: Check what was created
  ls -la .agent-workspace/
  # Should show your task directory

  # Test 3: Deploy a test agent
  TASK_ID="TASK-..."  # Use the ID from step 1
  agent-ctl deploy "test_agent" "$TASK_ID" "Test agent prompt"

  # Test 4: Check status
  agent-ctl status "$TASK_ID"

  # Test 5: Run Python orchestrator
  python3 orchestrator.py
  Step 6: Integrate with Claude (When Ready)
  To make agents actually work with Claude, modify the deploy script:
  bash# Edit .agent-workspace/scripts/deploy.sh
  # Replace the line:
  echo "Would deploy: claude --dangerously-skip-permissions -p \"${TASK_PROMPT}\""

  # With actual Claude deployment:
  BASH_ID=$(claude --dangerously-skip-permissions \
      --output-format stream-json \
      --verbose \
      -p "${TASK_PROMPT}" \
      --run-in-background 2>&1 | grep -oP 'bash_\w+' | head -1)
  üìÅ Final Directory Structure
  After setup, you should have:
  agent-orchestrator/
  ‚îú‚îÄ‚îÄ install_toolkit.sh         # Installation script
  ‚îú‚îÄ‚îÄ orchestrator.py            # Python orchestrator
  ‚îî‚îÄ‚îÄ .agent-workspace/
      ‚îú‚îÄ‚îÄ bin/
      ‚îÇ   ‚îú‚îÄ‚îÄ agent-ctl          # Main control command
      ‚îÇ   ‚îú‚îÄ‚îÄ update-progress    # Helper commands
      ‚îÇ   ‚îú‚îÄ‚îÄ escalate
      ‚îÇ   ‚îú‚îÄ‚îÄ write-finding
      ‚îÇ   ‚îî‚îÄ‚îÄ read-context
      ‚îú‚îÄ‚îÄ scripts/
      ‚îÇ   ‚îú‚îÄ‚îÄ init.sh           # Individual scripts
      ‚îÇ   ‚îú‚îÄ‚îÄ deploy.sh
      ‚îÇ   ‚îú‚îÄ‚îÄ status.sh
      ‚îÇ   ‚îú‚îÄ‚îÄ update.sh
      ‚îÇ   ‚îú‚îÄ‚îÄ monitor.sh
      ‚îÇ   ‚îú‚îÄ‚îÄ kill.sh
      ‚îÇ   ‚îú‚îÄ‚îÄ review.sh
      ‚îÇ   ‚îî‚îÄ‚îÄ report.sh
      ‚îî‚îÄ‚îÄ TASK-*/               # Task workspaces (created by init)
          ‚îú‚îÄ‚îÄ AGENT_REGISTRY.json
          ‚îú‚îÄ‚îÄ context/
          ‚îú‚îÄ‚îÄ progress/
          ‚îú‚îÄ‚îÄ findings/
          ‚îî‚îÄ‚îÄ ...
  üöÄ Quick Start Commands
  bash# 1. Create project directory
  mkdir agent-orchestrator && cd agent-orchestrator

  # 2. Create and run installer (copy the install_toolkit.sh content above)
  ./install_toolkit.sh

  # 3. Set PATH
  export PATH="$PWD/.agent-workspace/bin:$PATH"

  # 4. Create your first task
  agent-ctl init "My first orchestrated task"

  # 5. Run the Python orchestrator
  python3 orchestrator.py
  üí° Pro Tips

  Always set PATH: Add to your .bashrc or .zshrc:
  bashexport PATH="/path/to/agent-orchestrator/.agent-workspace/bin:$PATH"

  Test without Claude first: The scripts work standalone for testing
  Check logs: All progress is saved in JSON files under task directories
  Customize limits: Edit AGENT_REGISTRY.json to change max_agents, max_depth
  Debug mode: Add set -x to any script to see what it's doing

  This gives you a complete, working system you can test immediately, even without Claude integration![O    /   #!/usr/bin/env python3
  """
  Agent Orchestrator - Python Control System
  Uses the CLI toolkit for standardized agent management
  """

  import subprocess
  import json
  import time
  import threading
  from datetime import datetime, timedelta
  from typing import Dict, List, Optional, Tuple
  from dataclasses import dataclass
  from enum import Enum
  import os
  import re

  # ============================================================================
  # DATA MODELS
  # ============================================================================

  class AgentStatus(Enum):
      INITIALIZING = "initializing"
      RUNNING = "running"
      COMPLETED = "completed"
      FAILED = "failed"
      TERMINATED = "terminated"
      STUCK = "stuck"

  class Priority(Enum):
      P1_CRITICAL = "P1"
      P2_HIGH = "P2"
      P3_NORMAL = "P3"
      P4_LOW = "P4"

  @dataclass
  class Agent:
      id: str
      type: str
      bash_id: str
      status: AgentStatus
      progress: int
      parent: str
      depth: int
      started_at: datetime
      last_update: datetime

  @dataclass
  class Task:
      id: str
      description: str
      priority: Priority
      workspace: str
      agents: List[Agent]
      created_at: datetime
      deadline: datetime

  # ============================================================================
  # ORCHESTRATOR CLASS
  # ============================================================================

  class AgentOrchestrator:
      """
      Main orchestrator that manages agents using the CLI toolkit
      """
      
      def __init__(self, base_dir: str = ".agent-workspace"):
          self.base_dir = base_dir
          self.active_tasks: Dict[str, Task] = {}
          self.monitoring_threads: Dict[str, threading.Thread] = {}
          
          # Install toolkit if not exists
          self._ensure_toolkit_installed()
      
      def _ensure_toolkit_installed(self):
          """Ensure the CLI toolkit is installed"""
          if not os.path.exists(f"{self.base_dir}/scripts"):
              print("üì¶ Installing Agent Toolkit...")
              subprocess.run(["bash", "setup_agent_toolkit.sh"], check=True)
      
      def _run_command(self, command: str) -> Tuple[str, int]:
          """Execute CLI command and return output"""
          result = subprocess.run(
              command,
              shell=True,
              capture_output=True,
              text=True
          )
          return result.stdout.strip(), result.returncode
      
      # ========================================
      # TASK MANAGEMENT
      # ========================================
      
      def create_task(self, description: str, priority: Priority = Priority.P2_HIGH) -> str:
          """
          Initialize a new task workspace
          """
          print(f"üìã Creating task: {description}")
          
          # Use CLI to initialize
          output, _ = self._run_command(
              f"agent-ctl init '{description}' {priority.value} orchestrator"
          )
          
          # Extract task ID from output
          task_id = re.search(r"TASK-[\d\-\w]+", output).group(0)
          
          # Create Task object
          workspace = f"{self.base_dir}/{task_id}"
          task = Task(
              id=task_id,
              description=description,
              priority=priority,
              workspace=workspace,
              agents=[],
              created_at=datetime.now(),
              deadline=datetime.now() + timedelta(hours=2)
          )
          
          self.active_tasks[task_id] = task
          
          # Start monitoring thread
          self._start_monitoring(task_id)
          
          print(f"‚úÖ Task created: {task_id}")
          return task_id
      
      # ========================================
      # AGENT DEPLOYMENT
      # ========================================
      
      def deploy_agent(self, 
                      task_id: str, 
                      agent_type: str, 
                      prompt: str,
                      parent: str = "orchestrator") -> Optional[str]:
          """
          Deploy an agent using the CLI toolkit
          """
          if task_id not in self.active_tasks:
              print(f"‚ùå Task {task_id} not found")
              return None
          
          task = self.active_tasks[task_id]
          
          # Check if we should deploy (anti-spiral checks)
          if not self._should_deploy_agent(task, agent_type):
              print(f"‚ö†Ô∏è Deployment blocked for {agent_type}")
              return None
          
          print(f"ü§ñ Deploying {agent_type}...")
          
          # Deploy using CLI
          output, returncode = self._run_command(
              f"agent-ctl deploy '{agent_type}' '{task_id}' '{prompt}' '{parent}'"
          )
          
          if returncode != 0:
              print(f"‚ùå Failed to deploy {agent_type}")
              return None
          
          # Extract agent ID
          agent_id = re.search(r"Agent ID: ([\w\-]+)", output).group(1)
          
          print(f"‚úÖ Deployed: {agent_id}")
          return agent_id
      
      def _should_deploy_agent(self, task: Task, agent_type: str) -> bool:
          """
          Anti-spiral checks before deployment
          """
          # Read current registry
          registry_path = f"{task.workspace}/AGENT_REGISTRY.json"
          with open(registry_path, 'r') as f:
              registry = json.load(f)
          
          # Check 1: Max agents limit
          if registry['total_spawned'] >= registry['max_agents']:
              print(f"‚ùå Max agents ({registry['max_agents']}) reached")
              return False
          
          # Check 2: Already running?
          running_types = [a['type'] for a in registry['agents'] 
                          if a['status'] == 'running']
          if agent_type in running_types:
              print(f"‚ö†Ô∏è {agent_type} already running")
              return False
          
          # Check 3: Too many active?
          if registry['active_count'] >= 5:
              print(f"‚ö†Ô∏è {registry['active_count']} agents already active")
              return False
          
          return True
      
      # ========================================
      # MONITORING & INTERVENTION
      # ========================================
      
      def _start_monitoring(self, task_id: str):
          """Start monitoring thread for a task"""
          thread = threading.Thread(
              target=self._monitor_task,
              args=(task_id,),
              daemon=True
          )
          thread.start()
          self.monitoring_threads[task_id] = thread
      
      def _monitor_task(self, task_id: str):
          """
          Monitor task and intervene when necessary
          """
          task = self.active_tasks[task_id]
          stuck_checks = {}
          
          while task_id in self.active_tasks:
              try:
                  # Read registry
                  registry_path = f"{task.workspace}/AGENT_REGISTRY.json"
                  with open(registry_path, 'r') as f:
                      registry = json.load(f)
                  
                  # Check each running agent
                  for agent in registry['agents']:
                      if agent['status'] != 'running':
                          continue
                      
                      agent_id = agent['id']
                      last_update = datetime.fromisoformat(agent['last_update'])
                      time_since_update = (datetime.now() - last_update).seconds
                      
                      # Check if stuck
                      if time_since_update > 300:  # 5 minutes
                          if agent_id not in stuck_checks:
                              stuck_checks[agent_id] = 1
                          else:
                              stuck_checks[agent_id] += 1
                          
                          if stuck_checks[agent_id] >= 2:
                              self._handle_stuck_agent(task_id, agent_id, agent)
                              stuck_checks[agent_id] = 0
                      else:
                          stuck_checks.pop(agent_id, None)
                      
                      # Check progress
                      if agent['progress'] < 30 and time_since_update > 600:
                          self._handle_slow_progress(task_id, agent_id, agent)
                  
                  # Check for spiral
                  if registry['active_count'] > 5:
                      self._handle_spiral_condition(task_id, registry)
                  
                  # Check deadline
                  if datetime.now() > task.deadline:
                      self._handle_deadline_exceeded(task_id)
                  
                  time.sleep(30)  # Check every 30 seconds
                  
              except Exception as e:
                  print(f"‚ùå Monitoring error for {task_id}: {e}")
                  time.sleep(30)
      
      def _handle_stuck_agent(self, task_id: str, agent_id: str, agent_data: dict):
          """Handle a stuck agent"""
          print(f"üö® Agent {agent_id} is stuck!")
          
          agent_type = agent_data['type']
          progress = agent_data['progress']
          
          if progress < 30:
              # Early stage - try alternative approach
              print("   ‚Üí Deploying alternative approach")
              self.deploy_agent(
                  task_id,
                  f"alternative_{agent_type}",
                  f"Alternative approach for stuck {agent_type}",
                  "orchestrator"
              )
              # Kill stuck agent
              self._run_command(f"agent-ctl kill '{task_id}' '{agent_id}' 'Stuck - trying alternative'")
              
          elif progress < 70:
              # Mid stage - deploy helper
              print("   ‚Üí Deploying helper")
              self.deploy_agent(
                  task_id,
                  "problem_solver",
                  f"Help {agent_type} that is stuck at {progress}%",
                  "orchestrator"
              )
              
          else:
              # Late stage - deploy finisher
              print("   ‚Üí Deploying finisher")
              self.deploy_agent(
                  task_id,
                  "task_finisher",
                  f"Complete the remaining {100-progress}% of {agent_type}'s work",
                  "orchestrator"
              )
      
      def _handle_slow_progress(self, task_id: str, agent_id: str, agent_data: dict):
          """Handle agent with slow progress"""
          print(f"‚ö†Ô∏è Agent {agent_id} making slow progress ({agent_data['progress']}%)")
          
          # Deploy assistant
          self.deploy_agent(
              task_id,
              "assistant",
              f"Assist {agent_data['type']} to speed up progress",
              "orchestrator"
          )
      
      def _handle_spiral_condition(self, task_id: str, registry: dict):
          """Handle spiral condition (too many agents)"""
          print(f"üåÄ SPIRAL DETECTED! {registry['active_count']} agents active")
          
          # Kill newest agents
          active_agents = sorted(
              [a for a in registry['agents'] if a['status'] == 'running'],
              key=lambda x: x['started_at'],
              reverse=True
          )
          
          for agent in active_agents[3:]:  # Keep only 3 oldest
              print(f"   ‚Üí Killing {agent['id']}")
              self._run_command(
                  f"agent-ctl kill '{task_id}' '{agent['id']}' 'Spiral prevention'"
              )
      
      def _handle_deadline_exceeded(self, task_id: str):
          """Handle deadline exceeded"""
          print(f"‚è∞ DEADLINE EXCEEDED for {task_id}")
          
          # Deploy emergency finisher
          self.deploy_agent(
              task_id,
              "emergency_finisher",
              "URGENT: Complete task immediately with best effort solution",
              "orchestrator"
          )
      
      # ========================================
      # ORCHESTRATION PATTERNS
      # ========================================
      
      def orchestrate_investigation_fix_pattern(self, description: str) -> str:
          """
          Common pattern: Investigate ‚Üí Fix ‚Üí Review
          """
          # Create task
          task_id = self.create_task(description, Priority.P2_HIGH)
          
          # Phase 1: Investigation
          print("\nüîç Phase 1: Investigation")
          investigator = self.deploy_agent(
              task_id,
              "investigator",
              f"Investigate the root cause of: {description}"
          )
          
          # Wait for investigation
          self._wait_for_agent_completion(task_id, investigator, timeout=900)
          
          # Read findings
          findings = self._read_findings(task_id)
          
          # Phase 2: Implementation
          print("\nüîß Phase 2: Implementation")
          if "database" in str(findings).lower():
              fixer_type = "database_specialist"
          elif "performance" in str(findings).lower():
              fixer_type = "performance_optimizer"
          else:
              fixer_type = "general_fixer"
          
          fixer = self.deploy_agent(
              task_id,
              fixer_type,
              f"Fix the issues found: {findings}"
          )
          
          # Wait for fix
          self._wait_for_agent_completion(task_id, fixer, timeout=1200)
          
          # Phase 3: Review
          print("\n‚úÖ Phase 3: Review")
          reviewer = self.deploy_agent(
              task_id,
              "quality_reviewer",
              f"Review the fixes implemented by {fixer}"
          )
          
          # Wait for review
          self._wait_for_agent_completion(task_id, reviewer, timeout=600)
          
          # Generate report
          self._generate_report(task_id)
          
          return task_id
      
      def orchestrate_parallel_analysis(self, description: str, aspects: List[str]) -> str:
          """
          Deploy multiple analysts in parallel
          """
          task_id = self.create_task(description, Priority.P1_CRITICAL)
          
          print(f"\nüîÄ Deploying {len(aspects)} parallel analysts")
          
          agents = []
          for aspect in aspects:
              agent_id = self.deploy_agent(
                  task_id,
                  f"{aspect}_analyst",
                  f"Analyze {aspect} aspect of: {description}"
              )
              if agent_id:
                  agents.append(agent_id)
              time.sleep(2)  # Stagger deployments
          
          # Wait for all to complete
          for agent_id in agents:
              self._wait_for_agent_completion(task_id, agent_id, timeout=900)
          
          # Deploy synthesizer
          print("\nüîÑ Deploying synthesizer")
          synthesizer = self.deploy_agent(
              task_id,
              "synthesizer",
              "Synthesize findings from all analysts into coherent solution"
          )
          
          self._wait_for_agent_completion(task_id, synthesizer, timeout=600)
          
          return task_id
      
      def orchestrate_iterative_improvement(self, 
                                          description: str, 
                                          max_iterations: int = 3) -> str:
          """
          Iterative improvement pattern with quality gates
          """
          task_id = self.create_task(description, Priority.P2_HIGH)
          
          quality_threshold = 80
          current_quality = 0
          iteration = 0
          
          while current_quality < quality_threshold and iteration < max_iterations:
              iteration += 1
              print(f"\nüîÑ Iteration {iteration}/{max_iterations}")
              
              # Deploy implementer
              implementer = self.deploy_agent(
                  task_id,
                  f"implementer_v{iteration}",
                  f"Implement/improve solution for: {description} (iteration {iteration})"
              )
              
              self._wait_for_agent_completion(task_id, implementer, timeout=900)
              
              # Check quality
              quality = self._check_quality(task_id)
              current_quality = quality['score']
              
              print(f"   Quality Score: {current_quality}%")
              
              if current_quality < quality_threshold:
                  # Deploy improver
                  feedback = quality.get('feedback', 'Needs improvement')
                  improver = self.deploy_agent(
                      task_id,
                      f"improver_v{iteration}",
                      f"Improve based on feedback: {feedback}"
                  )
                  self._wait_for_agent_completion(task_id, improver, timeout=600)
          
          if current_quality >= quality_threshold:
              print(f"‚úÖ Quality threshold met: {current_quality}%")
          else:
              print(f"‚ö†Ô∏è Max iterations reached. Final quality: {current_quality}%")
          
          return task_id
      
      # ========================================
      # HELPER METHODS
      # ========================================
      
      def _wait_for_agent_completion(self, 
                                     task_id: str, 
                                     agent_id: str, 
                                     timeout: int = 600):
          """Wait for agent to complete with timeout"""
          start = time.time()
          
          while time.time() - start < timeout:
              output, _ = self._run_command(f"agent-ctl status '{task_id}'")
              
              if f"{agent_id}" in output and "100%" in output:
                  print(f"‚úÖ {agent_id} completed")
                  return True
              
              time.sleep(30)
          
          print(f"‚è±Ô∏è Timeout waiting for {agent_id}")
          return False
      
      def _read_findings(self, task_id: str) -> dict:
          """Read findings from workspace"""
          task = self.active_tasks[task_id]
          findings = {}
          
          findings_dir = f"{task.workspace}/findings"
          if os.path.exists(findings_dir):
              for file in os.listdir(findings_dir):
                  if file.endswith('.json'):
                      with open(f"{findings_dir}/{file}", 'r') as f:
                          data = json.load(f)
                          findings[data['key']] = data['value']
          
          return findings
      
      def _check_quality(self, task_id: str) -> dict:
          """Run quality check"""
          output, _ = self._run_command(
              f"cd {self.active_tasks[task_id].workspace} && check-quality"
          )
          
          # Parse quality score
          score_match = re.search(r"Quality Score: (\d+)%", output)
          score = int(score_match.group(1)) if score_match else 0
          
          return {
              'score': score,
              'output': output,
              'feedback': "Improve test coverage and documentation" if score < 80 else "Good"
          }
      
      def _generate_report(self, task_id: str):
          """Generate final report"""
          print("\nüìä Generating report...")
          output, _ = self._run_command(f"agent-ctl report '{task_id}' detailed")
          print(output)
      
      def get_task_status(self, task_id: str) -> dict:
          """Get current task status"""
          output, _ = self._run_command(f"agent-ctl status '{task_id}' true")
          return {'raw': output}
      
      def kill_all_agents(self, task_id: str):
          """Emergency kill all agents for a task"""
          print(f"üõë Killing all agents for {task_id}")
          
          registry_path = f"{self.active_tasks[task_id].workspace}/AGENT_REGISTRY.json"
          with open(registry_path, 'r') as f:
              registry = json.load(f)
          
          for agent in registry['agents']:
              if agent['status'] == 'running':
                  self._run_command(
                      f"agent-ctl kill '{task_id}' '{agent['id']}' 'Emergency shutdown'"
                  )

  # ============================================================================
  # USAGE EXAMPLES
  # ============================================================================

  def main():
      """
      Example usage of the orchestrator
      """
      orchestrator = AgentOrchestrator()
      
      # Example 1: Simple investigation and fix
      print("=" * 60)
      print("EXAMPLE 1: Investigation ‚Üí Fix ‚Üí Review Pattern")
      print("=" * 60)
      
      task_id = orchestrator.orchestrate_investigation_fix_pattern(
          "Users reporting empty measurement screen despite data in database"
      )
      
      print(f"\n‚úÖ Task {task_id} completed")
      print(orchestrator.get_task_status(task_id)['raw'])
      
      # Example 2: Parallel analysis
      print("\n" + "=" * 60)
      print("EXAMPLE 2: Parallel Analysis Pattern")
      print("=" * 60)
      
      task_id = orchestrator.orchestrate_parallel_analysis(
          "Optimize application performance",
          aspects=["database", "frontend", "api", "caching"]
      )
      
      # Example 3: Iterative improvement
      print("\n" + "=" * 60)
      print("EXAMPLE 3: Iterative Improvement Pattern")
      print("=" * 60)
      
      task_id = orchestrator.orchestrate_iterative_improvement(
          "Refactor authentication system for better security",
          max_iterations=3
      )
      
      # Example 4: Manual control
      print("\n" + "=" * 60)
      print("EXAMPLE 4: Manual Agent Control")
      print("=" * 60)
      
      # Create task
      task_id = orchestrator.create_task("Fix performance regression in search", Priority.P1_CRITICAL)
      
      # Deploy specific agents
      profiler = orchestrator.deploy_agent(
          task_id,
          "performance_profiler",
          "Profile the search functionality and identify bottlenecks"
      )
      
      # Monitor in real-time
      for _ in range(10):
          print(orchestrator.get_task_status(task_id)['raw'])
          time.sleep(30)
      
      # Deploy optimizer based on findings
      optimizer = orchestrator.deploy_agent(
          task_id,
          "query_optimizer",
          "Optimize the slow queries identified by profiler",
          parent=profiler  # Set parent for hierarchy
      )
      
      # If things go wrong, kill all
      # orchestrator.kill_all_agents(task_id)

  if __name__ == "__main__":
      main()[O    /  #!/bin/bash

  # ============================================================================
  # AGENT ORCHESTRATION TOOLKIT
  # A comprehensive set of CLI tools for agent management
  # ============================================================================

  # Configuration
  AGENT_BASE_DIR="${AGENT_BASE_DIR:-.agent-workspace}"
  SCRIPTS_DIR="${AGENT_BASE_DIR}/scripts"
  REGISTRY_FILE="AGENT_REGISTRY.json"
  MAX_AGENTS=10
  MAX_DEPTH=3

  # ============================================================================
  # INSTALLATION SCRIPT
  # ============================================================================

  cat << 'INSTALL_SCRIPT' > setup_agent_toolkit.sh
  #!/bin/bash

  echo "üöÄ Installing Agent Orchestration Toolkit..."

  # Create base directories
  mkdir -p .agent-workspace/{scripts,templates,bin}

  # Create the main orchestrator command
  cat << 'MAIN_CMD' > .agent-workspace/bin/agent-ctl
  #!/bin/bash
  AGENT_BASE_DIR=".agent-workspace"
  COMMAND=$1
  shift

  case $COMMAND in
      init|deploy|status|update|monitor|kill|review|report)
          $AGENT_BASE_DIR/scripts/${COMMAND}.sh "$@"
          ;;
      *)
          echo "Usage: agent-ctl {init|deploy|status|update|monitor|kill|review|report} [options]"
          exit 1
          ;;
  esac
  MAIN_CMD

  chmod +x .agent-workspace/bin/agent-ctl

  # Add to PATH for current session
  export PATH="$PWD/.agent-workspace/bin:$PATH"
  echo 'export PATH="$PWD/.agent-workspace/bin:$PATH"' >> ~/.bashrc

  echo "‚úÖ Toolkit installed! Commands available:"
  echo "   agent-ctl init    - Initialize new task workspace"
  echo "   agent-ctl deploy  - Deploy new agent"
  echo "   agent-ctl status  - Check agent status"
  echo "   agent-ctl update  - Update agent progress"
  echo "   agent-ctl monitor - Monitor all agents"
  echo "   agent-ctl kill    - Terminate agent"
  echo "   agent-ctl review  - Request peer review"
  echo "   agent-ctl report  - Generate reports"
  INSTALL_SCRIPT

  # ============================================================================
  # CORE SCRIPTS
  # ============================================================================

  # ------------------------------------
  # 1. INIT SCRIPT - Initialize Workspace
  # ------------------------------------
  cat << 'INIT_SCRIPT' > ${SCRIPTS_DIR}/init.sh
  #!/bin/bash

  TASK_DESC="${1:-No description provided}"
  PRIORITY="${2:-P2}"
  REQUESTER="${3:-user}"

  # Generate IDs
  TASK_ID="TASK-$(date +%Y%m%d-%H%M%S)-$(uuidgen | cut -c1-8)"
  WORKSPACE="${AGENT_BASE_DIR}/${TASK_ID}"

  echo "üìÇ Initializing workspace for task: ${TASK_ID}"

  # Create directory structure
  mkdir -p "${WORKSPACE}"/{context,progress,handoffs,tickets,reviews,rollbacks,knowledge,metrics,escalations,standups}

  # Initialize Agent Registry
  cat << EOF > "${WORKSPACE}/${REGISTRY_FILE}"
  {
    "task_id": "${TASK_ID}",
    "task_description": "${TASK_DESC}",
    "created_at": "$(date -Iseconds)",
    "workspace": "${WORKSPACE}",
    "status": "INITIALIZED",
    "agents": [],
    "max_agents": ${MAX_AGENTS},
    "max_depth": ${MAX_DEPTH},
    "total_spawned": 0,
    "active_count": 0,
    "completed_count": 0,
    "failed_count": 0
  }
  EOF

  # Initialize Spawn Rules
  cat << 'EOF' > "${WORKSPACE}/SPAWN_RULES.json"
  {
    "orchestrator": ["investigator", "implementer", "reviewer", "performance_doctor"],
    "investigator": ["deep_analyzer"],
    "implementer": ["code_writer", "test_writer"],
    "reviewer": [],
    "performance_doctor": ["profiler"],
    "deep_analyzer": [],
    "code_writer": [],
    "test_writer": [],
    "profiler": []
  }
  EOF

  # Create main ticket
  TICKET_ID="TKT-${TASK_ID:5:20}"
  cat << EOF > "${WORKSPACE}/tickets/${TICKET_ID}.json"
  {
    "ticket_id": "${TICKET_ID}",
    "task_id": "${TASK_ID}",
    "title": "${TASK_DESC}",
    "priority": "${PRIORITY}",
    "requester": "${REQUESTER}",
    "created_at": "$(date -Iseconds)",
    "status": "OPEN",
    "assigned_to": null,
    "deadline": "$(date -Iseconds -d '+2 hours')",
    "acceptance_criteria": [],
    "progress_updates": []
  }
  EOF

  # Create baseline metrics
  cat << EOF > "${WORKSPACE}/metrics/baseline.json"
  {
    "captured_at": "$(date -Iseconds)",
    "performance_ms": null,
    "memory_mb": null,
    "test_pass_rate": null,
    "error_rate": null
  }
  EOF

  # Output workspace info
  echo "‚úÖ Workspace initialized!"
  echo "   Task ID: ${TASK_ID}"
  echo "   Workspace: ${WORKSPACE}"
  echo "   Ticket: ${TICKET_ID}"
  echo ""
  echo "Next step: agent-ctl deploy <agent_type> \"${TASK_ID}\" \"<task_description>\""

  # Return task ID for scripting
  echo "TASK_ID=${TASK_ID}" > "${WORKSPACE}/.env"
  echo "${TASK_ID}"
  INIT_SCRIPT

  # ------------------------------------
  # 2. DEPLOY SCRIPT - Deploy New Agent
  # ------------------------------------
  cat << 'DEPLOY_SCRIPT' > ${SCRIPTS_DIR}/deploy.sh
  #!/bin/bash

  AGENT_TYPE="${1:?Error: Agent type required}"
  TASK_ID="${2:?Error: Task ID required}"
  TASK_PROMPT="${3:?Error: Task prompt required}"
  PARENT_AGENT="${4:-orchestrator}"

  WORKSPACE="${AGENT_BASE_DIR}/${TASK_ID}"
  REGISTRY="${WORKSPACE}/${REGISTRY_FILE}"

  # Validate workspace exists
  if [ ! -f "${REGISTRY}" ]; then
      echo "‚ùå Error: Task ${TASK_ID} not found. Run 'agent-ctl init' first."
      exit 1
  fi

  # Read registry
  REGISTRY_DATA=$(cat "${REGISTRY}")
  TOTAL_SPAWNED=$(echo "${REGISTRY_DATA}" | jq -r '.total_spawned')
  ACTIVE_COUNT=$(echo "${REGISTRY_DATA}" | jq -r '.active_count')
  MAX_AGENTS=$(echo "${REGISTRY_DATA}" | jq -r '.max_agents')

  # Check limits
  if [ "${TOTAL_SPAWNED}" -ge "${MAX_AGENTS}" ]; then
      echo "‚ùå Max agents (${MAX_AGENTS}) reached. Cannot deploy ${AGENT_TYPE}"
      exit 1
  fi

  if [ "${ACTIVE_COUNT}" -ge 5 ]; then
      echo "‚ö†Ô∏è  Warning: ${ACTIVE_COUNT} agents already active. Consider waiting."
  fi

  # Check spawn rules
  SPAWN_RULES=$(cat "${WORKSPACE}/SPAWN_RULES.json")
  ALLOWED=$(echo "${SPAWN_RULES}" | jq -r ".${PARENT_AGENT}[]" 2>/dev/null | grep -c "^${AGENT_TYPE}$")

  if [ "${ALLOWED}" -eq 0 ] && [ "${PARENT_AGENT}" != "orchestrator" ]; then
      echo "‚ùå ${PARENT_AGENT} cannot spawn ${AGENT_TYPE}"
      exit 1
  fi

  # Generate agent ID
  AGENT_ID="${AGENT_TYPE}-$(date +%H%M%S)-$(uuidgen | cut -c1-6)"

  echo "ü§ñ Deploying agent: ${AGENT_ID}"

  # Create agent prompt with toolkit commands
  AGENT_PROMPT="
  ü§ñ AGENT: ${AGENT_TYPE}
  üÜî ID: ${AGENT_ID}
  üìã TASK: ${TASK_ID}
  üìÅ WORKSPACE: ${WORKSPACE}

  AVAILABLE COMMANDS:
  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  ‚Ä¢ update-progress <percent> <message>  - Update your progress
  ‚Ä¢ request-review <file_path>           - Request code review
  ‚Ä¢ escalate <issue>                      - Escalate a blocker
  ‚Ä¢ read-context                         - Read task context
  ‚Ä¢ write-finding <key> <value>          - Document findings
  ‚Ä¢ check-quality                        - Run quality checks
  ‚Ä¢ create-rollback                      - Create rollback point

  YOUR TASK:
  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  ${TASK_PROMPT}

  EXECUTION PROTOCOL:
  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  1. Start by reading context:
     read-context

  2. Update progress every 2-3 minutes:
     update-progress 25 \"Analyzing database queries\"

  3. Document findings:
     write-finding \"root_cause\" \"N+1 query in measurements controller\"

  4. If stuck, escalate:
     escalate \"Cannot access production database\"

  5. When complete:
     update-progress 100 \"Task completed successfully\"
  "

  # Deploy agent via Claude
  BASH_ID=$(claude --dangerously-skip-permissions \
      --output-format stream-json \
      --verbose \
      -p "${AGENT_PROMPT}" \
      --run-in-background 2>&1 | grep -oP 'bash_\w+' | head -1)

  # Update registry
  REGISTRY_UPDATE=$(echo "${REGISTRY_DATA}" | jq \
      --arg agent_id "${AGENT_ID}" \
      --arg agent_type "${AGENT_TYPE}" \
      --arg bash_id "${BASH_ID}" \
      --arg parent "${PARENT_AGENT}" \
      --arg started_at "$(date -Iseconds)" \
      '.agents += [{
          "id": $agent_id,
          "type": $agent_type,
          "bash_id": $bash_id,
          "parent": $parent,
          "status": "running",
          "started_at": $started_at,
          "progress": 0,
          "last_update": $started_at
      }] |
      .total_spawned += 1 |
      .active_count += 1')

  echo "${REGISTRY_UPDATE}" > "${REGISTRY}"

  echo "‚úÖ Agent deployed!"
  echo "   Agent ID: ${AGENT_ID}"
  echo "   Bash ID: ${BASH_ID}"
  echo "   Type: ${AGENT_TYPE}"
  echo ""
  echo "Monitor with: agent-ctl status ${TASK_ID}"

  # Return agent ID
  echo "${AGENT_ID}"
  DEPLOY_SCRIPT

  # ------------------------------------
  # 3. UPDATE SCRIPT - Update Agent Progress
  # ------------------------------------
  cat << 'UPDATE_SCRIPT' > ${SCRIPTS_DIR}/update.sh
  #!/bin/bash

  # This script is called BY agents to update their progress

  AGENT_ID="${1:?Error: Agent ID required}"
  PROGRESS="${2:?Error: Progress percentage required}"
  MESSAGE="${3:-No message}"
  TASK_ID="${4}"

  # Find workspace by agent ID if task not provided
  if [ -z "${TASK_ID}" ]; then
      WORKSPACE=$(find "${AGENT_BASE_DIR}" -name "${REGISTRY_FILE}" -exec grep -l "${AGENT_ID}" {} \; | head -1 | xargs dirname)
  else
      WORKSPACE="${AGENT_BASE_DIR}/${TASK_ID}"
  fi

  if [ -z "${WORKSPACE}" ] || [ ! -d "${WORKSPACE}" ]; then
      echo "‚ùå Error: Cannot find workspace for agent ${AGENT_ID}"
      exit 1
  fi

  # Create progress update
  PROGRESS_FILE="${WORKSPACE}/progress/${AGENT_ID}_$(date +%s).json"
  cat << EOF > "${PROGRESS_FILE}"
  {
    "agent_id": "${AGENT_ID}",
    "timestamp": "$(date -Iseconds)",
    "progress": ${PROGRESS},
    "message": "${MESSAGE}",
    "memory_usage_mb": $(ps aux | grep "${AGENT_ID}" | awk '{sum+=$6} END {print sum/1024}' 2>/dev/null || echo 0),
    "status": $([ "${PROGRESS}" -eq 100 ] && echo '"completed"' || echo '"in_progress"')
  }
  EOF

  # Update registry
  REGISTRY="${WORKSPACE}/${REGISTRY_FILE}"
  REGISTRY_DATA=$(cat "${REGISTRY}")
  UPDATED_REGISTRY=$(echo "${REGISTRY_DATA}" | jq \
      --arg agent_id "${AGENT_ID}" \
      --arg progress "${PROGRESS}" \
      --arg last_update "$(date -Iseconds)" \
      --arg status $([ "${PROGRESS}" -eq 100 ] && echo "completed" || echo "running") \
      '(.agents[] | select(.id == $agent_id)) |= (
          .progress = ($progress | tonumber) |
          .last_update = $last_update |
          .status = $status
      ) |
      if $status == "completed" then
          .active_count -= 1 |
          .completed_count += 1
      else . end')

  echo "${UPDATED_REGISTRY}" > "${REGISTRY}"

  echo "‚úÖ Progress updated: ${PROGRESS}% - ${MESSAGE}"

  # Check for completion
  if [ "${PROGRESS}" -eq 100 ]; then
      echo "üéâ Agent ${AGENT_ID} completed!"
      
      # Trigger any pending reviews
      if [ -f "${WORKSPACE}/handoffs/needs_review_${AGENT_ID}.flag" ]; then
          agent-ctl review "${TASK_ID}" "${AGENT_ID}"
      fi
  fi
  UPDATE_SCRIPT

  # ------------------------------------
  # 4. STATUS SCRIPT - Check Status
  # ------------------------------------
  cat << 'STATUS_SCRIPT' > ${SCRIPTS_DIR}/status.sh
  #!/bin/bash

  TASK_ID="${1:?Error: Task ID required}"
  DETAILED="${2:-false}"

  WORKSPACE="${AGENT_BASE_DIR}/${TASK_ID}"
  REGISTRY="${WORKSPACE}/${REGISTRY_FILE}"

  if [ ! -f "${REGISTRY}" ]; then
      echo "‚ùå Error: Task ${TASK_ID} not found"
      exit 1
  fi

  # Read registry
  REGISTRY_DATA=$(cat "${REGISTRY}")

  # Display summary
  echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
  echo "üìä TASK STATUS: ${TASK_ID}"
  echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
  echo ""
  echo "Task: $(echo "${REGISTRY_DATA}" | jq -r '.task_description')"
  echo "Created: $(echo "${REGISTRY_DATA}" | jq -r '.created_at')"
  echo "Status: $(echo "${REGISTRY_DATA}" | jq -r '.status')"
  echo ""
  echo "AGENTS:"
  echo "‚îú‚îÄ Total Spawned: $(echo "${REGISTRY_DATA}" | jq -r '.total_spawned')"
  echo "‚îú‚îÄ Currently Active: $(echo "${REGISTRY_DATA}" | jq -r '.active_count')"
  echo "‚îú‚îÄ Completed: $(echo "${REGISTRY_DATA}" | jq -r '.completed_count')"
  echo "‚îî‚îÄ Failed: $(echo "${REGISTRY_DATA}" | jq -r '.failed_count')"
  echo ""

  # Show agent details
  echo "ACTIVE AGENTS:"
  echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
  echo "${REGISTRY_DATA}" | jq -r '.agents[] | select(.status == "running") | 
      "‚Ä¢ \(.id)\n  Type: \(.type) | Progress: \(.progress)% | Last Update: \(.last_update)"'

  if [ "${DETAILED}" == "true" ]; then
      echo ""
      echo "RECENT PROGRESS UPDATES:"
      echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
      ls -t "${WORKSPACE}"/progress/*.json 2>/dev/null | head -5 | while read -r file; do
          jq -r '"‚Ä¢ [\(.timestamp)] \(.agent_id): \(.progress)% - \(.message)"' "$file"
      done
      
      echo ""
      echo "ESCALATIONS:"
      echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
      ls "${WORKSPACE}"/escalations/*.json 2>/dev/null | while read -r file; do
          jq -r '"‚ö†Ô∏è  \(.agent_id): \(.issue)"' "$file"
      done
  fi

  echo ""
  echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
  STATUS_SCRIPT

  # ------------------------------------
  # 5. MONITOR SCRIPT - Active Monitoring
  # ------------------------------------
  cat << 'MONITOR_SCRIPT' > ${SCRIPTS_DIR}/monitor.sh
  #!/bin/bash

  TASK_ID="${1:?Error: Task ID required}"
  INTERVAL="${2:-30}"

  WORKSPACE="${AGENT_BASE_DIR}/${TASK_ID}"
  REGISTRY="${WORKSPACE}/${REGISTRY_FILE}"

  echo "üëÅÔ∏è  Starting monitor for ${TASK_ID} (interval: ${INTERVAL}s)"
  echo "Press Ctrl+C to stop monitoring"
  echo ""

  # Monitoring loop
  while true; do
      clear
      
      # Show status
      agent-ctl status "${TASK_ID}" true
      
      # Check for issues
      REGISTRY_DATA=$(cat "${REGISTRY}")
      ACTIVE_COUNT=$(echo "${REGISTRY_DATA}" | jq -r '.active_count')
      
      # Check for stuck agents (no update in 5 minutes)
      CURRENT_TIME=$(date +%s)
      echo "${REGISTRY_DATA}" | jq -r '.agents[] | select(.status == "running") | "\(.id)|\(.last_update)"' | while IFS='|' read -r agent_id last_update; do
          LAST_UPDATE_TIME=$(date -d "${last_update}" +%s 2>/dev/null || echo 0)
          TIME_DIFF=$((CURRENT_TIME - LAST_UPDATE_TIME))
          
          if [ ${TIME_DIFF} -gt 300 ]; then
              echo "‚ö†Ô∏è  WARNING: ${agent_id} hasn't updated in $((TIME_DIFF/60)) minutes"
              
              # Auto-escalate if stuck too long
              if [ ${TIME_DIFF} -gt 600 ]; then
                  echo "üö® AUTO-ESCALATING: ${agent_id} stuck for >10 minutes"
                  agent-ctl escalate "${TASK_ID}" "${agent_id}" "Agent unresponsive"
              fi
          fi
      done
      
      # Check for spiral condition
      if [ ${ACTIVE_COUNT} -gt 5 ]; then
          echo ""
          echo "üö® SPIRAL WARNING: ${ACTIVE_COUNT} agents active simultaneously!"
          echo "Consider killing some agents: agent-ctl kill ${TASK_ID} <agent_id>"
      fi
      
      sleep "${INTERVAL}"
  done
  MONITOR_SCRIPT

  # ------------------------------------
  # 6. KILL SCRIPT - Terminate Agent
  # ------------------------------------
  cat << 'KILL_SCRIPT' > ${SCRIPTS_DIR}/kill.sh
  #!/bin/bash

  TASK_ID="${1:?Error: Task ID required}"
  AGENT_ID="${2:?Error: Agent ID required}"
  REASON="${3:-Manual termination}"

  WORKSPACE="${AGENT_BASE_DIR}/${TASK_ID}"
  REGISTRY="${WORKSPACE}/${REGISTRY_FILE}"

  # Get bash ID from registry
  BASH_ID=$(jq -r --arg id "${AGENT_ID}" '.agents[] | select(.id == $id) | .bash_id' "${REGISTRY}")

  if [ -z "${BASH_ID}" ]; then
      echo "‚ùå Error: Agent ${AGENT_ID} not found"
      exit 1
  fi

  echo "üõë Terminating agent ${AGENT_ID} (${BASH_ID})"

  # Kill the bash process
  kill -9 $(ps aux | grep "${BASH_ID}" | grep -v grep | awk '{print $2}') 2>/dev/null || true

  # Update registry
  REGISTRY_DATA=$(cat "${REGISTRY}")
  UPDATED_REGISTRY=$(echo "${REGISTRY_DATA}" | jq \
      --arg agent_id "${AGENT_ID}" \
      --arg terminated_at "$(date -Iseconds)" \
      --arg reason "${REASON}" \
      '(.agents[] | select(.id == $agent_id)) |= (
          .status = "terminated" |
          .terminated_at = $terminated_at |
          .termination_reason = $reason
      ) |
      .active_count -= 1 |
      .failed_count += 1')

  echo "${UPDATED_REGISTRY}" > "${REGISTRY}"

  # Log termination
  cat << EOF > "${WORKSPACE}/escalations/terminated_${AGENT_ID}.json"
  {
    "agent_id": "${AGENT_ID}",
    "bash_id": "${BASH_ID}",
    "terminated_at": "$(date -Iseconds)",
    "reason": "${REASON}"
  }
  EOF

  echo "‚úÖ Agent ${AGENT_ID} terminated"
  KILL_SCRIPT

  # ------------------------------------
  # 7. REVIEW SCRIPT - Request Review
  # ------------------------------------
  cat << 'REVIEW_SCRIPT' > ${SCRIPTS_DIR}/review.sh
  #!/bin/bash

  TASK_ID="${1:?Error: Task ID required}"
  AGENT_ID="${2:?Error: Agent ID to review required}"
  REVIEWER_TYPE="${3:-reviewer}"

  WORKSPACE="${AGENT_BASE_DIR}/${TASK_ID}"

  echo "üìã Requesting review for ${AGENT_ID}'s work"

  # Create review request
  REVIEW_ID="REV-$(date +%H%M%S)"
  cat << EOF > "${WORKSPACE}/reviews/request_${REVIEW_ID}.json"
  {
    "review_id": "${REVIEW_ID}",
    "task_id": "${TASK_ID}",
    "agent_to_review": "${AGENT_ID}",
    "requested_at": "$(date -Iseconds)",
    "status": "pending",
    "reviewer": null
  }
  EOF

  # Deploy reviewer agent
  REVIEW_PROMPT="Review the work completed by ${AGENT_ID} in task ${TASK_ID}. 
  Check for quality, completeness, and potential issues.
  Write your review to: ${WORKSPACE}/reviews/review_${REVIEW_ID}.json"

  REVIEWER_ID=$(agent-ctl deploy "${REVIEWER_TYPE}" "${TASK_ID}" "${REVIEW_PROMPT}")

  # Update review request with reviewer
  jq --arg reviewer "${REVIEWER_ID}" '.reviewer = $reviewer | .status = "in_progress"' \
      "${WORKSPACE}/reviews/request_${REVIEW_ID}.json" > "${WORKSPACE}/reviews/request_${REVIEW_ID}.tmp"
  mv "${WORKSPACE}/reviews/request_${REVIEW_ID}.tmp" "${WORKSPACE}/reviews/request_${REVIEW_ID}.json"

  echo "‚úÖ Review requested"
  echo "   Review ID: ${REVIEW_ID}"
  echo "   Reviewer: ${REVIEWER_ID}"
  REVIEW_SCRIPT

  # ------------------------------------
  # 8. REPORT SCRIPT - Generate Reports
  # ------------------------------------
  cat << 'REPORT_SCRIPT' > ${SCRIPTS_DIR}/report.sh
  #!/bin/bash

  TASK_ID="${1:?Error: Task ID required}"
  REPORT_TYPE="${2:-summary}"  # summary, detailed, metrics

  WORKSPACE="${AGENT_BASE_DIR}/${TASK_ID}"
  REGISTRY="${WORKSPACE}/${REGISTRY_FILE}"

  echo "üìä Generating ${REPORT_TYPE} report for ${TASK_ID}"

  REGISTRY_DATA=$(cat "${REGISTRY}")
  REPORT_FILE="${WORKSPACE}/reports/report_$(date +%Y%m%d_%H%M%S).json"
  mkdir -p "${WORKSPACE}/reports"

  case ${REPORT_TYPE} in
      summary)
          cat << EOF > "${REPORT_FILE}"
  {
    "task_id": "${TASK_ID}",
    "generated_at": "$(date -Iseconds)",
    "type": "summary",
    "task_description": $(echo "${REGISTRY_DATA}" | jq '.task_description'),
    "status": $(echo "${REGISTRY_DATA}" | jq '.status'),
    "metrics": {
      "total_agents": $(echo "${REGISTRY_DATA}" | jq '.total_spawned'),
      "completed": $(echo "${REGISTRY_DATA}" | jq '.completed_count'),
      "failed": $(echo "${REGISTRY_DATA}" | jq '.failed_count'),
      "duration_minutes": $(( ($(date +%s) - $(date -d "$(echo "${REGISTRY_DATA}" | jq -r '.created_at')" +%s)) / 60 ))
    },
    "success_rate": $(echo "${REGISTRY_DATA}" | jq '(.completed_count / .total_spawned * 100) | floor')
  }
  EOF
          ;;
          
      detailed)
          # Gather all data
          PROGRESS_COUNT=$(ls "${WORKSPACE}"/progress/*.json 2>/dev/null | wc -l)
          ESCALATION_COUNT=$(ls "${WORKSPACE}"/escalations/*.json 2>/dev/null | wc -l)
          REVIEW_COUNT=$(ls "${WORKSPACE}"/reviews/*.json 2>/dev/null | wc -l)
          
          cat << EOF > "${REPORT_FILE}"
  {
    "task_id": "${TASK_ID}",
    "generated_at": "$(date -Iseconds)",
    "type": "detailed",
    "registry": ${REGISTRY_DATA},
    "statistics": {
      "progress_updates": ${PROGRESS_COUNT},
      "escalations": ${ESCALATION_COUNT},
      "reviews": ${REVIEW_COUNT}
    },
    "timeline": [
      $(ls -t "${WORKSPACE}"/progress/*.json 2>/dev/null | while read -r file; do
          jq -c '{time: .timestamp, agent: .agent_id, progress: .progress, message: .message}' "$file"
      done | paste -sd,)
    ],
    "final_state": {
      "all_complete": $([ $(echo "${REGISTRY_DATA}" | jq '.active_count') -eq 0 ] && echo "true" || echo "false"),
      "has_failures": $([ $(echo "${REGISTRY_DATA}" | jq '.failed_count') -gt 0 ] && echo "true" || echo "false")
    }
  }
  EOF
          ;;
          
      metrics)
          # Performance metrics
          cat << EOF > "${REPORT_FILE}"
  {
    "task_id": "${TASK_ID}",
    "generated_at": "$(date -Iseconds)",
    "type": "metrics",
    "performance": {
      "avg_completion_time_minutes": $(
          ls "${WORKSPACE}"/progress/*_100_*.json 2>/dev/null | while read -r file; do
              jq -r '.timestamp' "$file"
          done | awk '{print $1}' | head -1 | xargs -I {} date -d {} +%s | awk -v start=$(date -d "$(echo "${REGISTRY_DATA}" | jq -r '.created_at')" +%s) '{print ($1-start)/60}'
      ),
      "parallel_efficiency": $(echo "${REGISTRY_DATA}" | jq '(.completed_count / (.total_spawned * 1.5) * 100) | floor'),
      "resource_usage": {
        "total_compute_minutes": $(( $(echo "${REGISTRY_DATA}" | jq '.total_spawned') * 5 )),
        "peak_concurrent_agents": 5
      }
    }
  }
  EOF
          ;;
  esac

  echo "‚úÖ Report generated: ${REPORT_FILE}"
  cat "${REPORT_FILE}" | jq '.'
  REPORT_SCRIPT

  # ------------------------------------
  # 9. HELPER COMMANDS for Agents
  # ------------------------------------

  # update-progress command for agents
  cat << 'HELPER_UPDATE_PROGRESS' > ${SCRIPTS_DIR}/update-progress
  #!/bin/bash
  # Simple wrapper for agents to call
  AGENT_ID="${AGENT_ID:-unknown}"
  agent-ctl update "${AGENT_ID}" "$@"
  HELPER_UPDATE_PROGRESS

  # escalate command for agents
  cat << 'HELPER_ESCALATE' > ${SCRIPTS_DIR}/escalate
  #!/bin/bash
  AGENT_ID="${AGENT_ID:-unknown}"
  ISSUE="${1:-Unknown issue}"
  WORKSPACE="${WORKSPACE:-.}"

  cat << EOF > "${WORKSPACE}/escalations/escalation_$(date +%s).json"
  {
    "agent_id": "${AGENT_ID}",
    "timestamp": "$(date -Iseconds)",
    "issue": "${ISSUE}",
    "status": "open"
  }
  EOF

  echo "üö® Escalation created: ${ISSUE}"
  HELPER_ESCALATE

  # write-finding command for agents
  cat << 'HELPER_WRITE_FINDING' > ${SCRIPTS_DIR}/write-finding
  #!/bin/bash
  KEY="${1:?Error: Key required}"
  VALUE="${2:?Error: Value required}"
  AGENT_ID="${AGENT_ID:-unknown}"
  WORKSPACE="${WORKSPACE:-.}"

  mkdir -p "${WORKSPACE}/findings"
  cat << EOF > "${WORKSPACE}/findings/${KEY}_${AGENT_ID}.json"
  {
    "key": "${KEY}",
    "value": "${VALUE}",
    "agent_id": "${AGENT_ID}",
    "timestamp": "$(date -Iseconds)"
  }
  EOF

  echo "‚úÖ Finding recorded: ${KEY}"
  HELPER_WRITE_FINDING

  # read-context command for agents
  cat << 'HELPER_READ_CONTEXT' > ${SCRIPTS_DIR}/read-context
  #!/bin/bash
  WORKSPACE="${WORKSPACE:-.}"

  echo "ÔøΩÔøΩ Reading task context..."
  echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"

  # Read ticket
  if ls "${WORKSPACE}"/tickets/*.json >/dev/null 2>&1; then
      echo "TICKET:"
      jq -r '.title, .acceptance_criteria[]' "${WORKSPACE}"/tickets/*.json | head -10
      echo ""
  fi

  # Read previous findings
  if ls "${WORKSPACE}"/findings/*.json >/dev/null 2>&1; then
      echo "PREVIOUS FINDINGS:"
      jq -r '"‚Ä¢ " + .key + ": " + .value' "${WORKSPACE}"/findings/*.json
      echo ""
  fi

  # Read knowledge base
  if ls "${WORKSPACE}"/knowledge/*.json >/dev/null 2>&1; then
      echo "RELEVANT KNOWLEDGE:"
      jq -r '.key_insights[]' "${WORKSPACE}"/knowledge/*.json | head -5
  fi

  echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
  HELPER_READ_CONTEXT

  # create-rollback command for agents
  cat << 'HELPER_CREATE_ROLLBACK' > ${SCRIPTS_DIR}/create-rollback
  #!/bin/bash
  AGENT_ID="${AGENT_ID:-unknown}"
  WORKSPACE="${WORKSPACE:-.}"
  DESCRIPTION="${1:-Checkpoint}"

  # Create git commit
  git add -A 2>/dev/null
  COMMIT=$(git commit -m "Rollback point: ${AGENT_ID} - ${DESCRIPTION}" 2>/dev/null | grep -oP '\[[\w\s]+ \K[\w]+' || echo "no-git")

  # Save rollback point
  cat << EOF > "${WORKSPACE}/rollbacks/rollback_${AGENT_ID}_$(date +%s).json"
  {
    "agent_id": "${AGENT_ID}",
    "commit": "${COMMIT}",
    "description": "${DESCRIPTION}",
    "timestamp": "$(date -Iseconds)"
  }
  EOF

  echo "‚úÖ Rollback point created: ${COMMIT}"
  HELPER_CREATE_ROLLBACK

  # check-quality command for agents
  cat << 'HELPER_CHECK_QUALITY' > ${SCRIPTS_DIR}/check-quality
  #!/bin/bash
  WORKSPACE="${WORKSPACE:-.}"

  echo "üîç Running quality checks..."

  CHECKS_PASSED=0
  TOTAL_CHECKS=4

  # Check 1: Tests passing
  if npm test >/dev/null 2>&1; then
      echo "‚úÖ Tests passing"
      ((CHECKS_PASSED++))
  else
      echo "‚ùå Tests failing"
  fi

  # Check 2: No syntax errors
  if find . -name "*.js" -o -name "*.py" | xargs -I {} sh -c 'node --check {} 2>/dev/null || python3 -m py_compile {} 2>/dev/null' ; then
      echo "‚úÖ No syntax errors"
      ((CHECKS_PASSED++))
  else
      echo "‚ùå Syntax errors found"
  fi

  # Check 3: Performance not degraded
  # (simplified check - would be more complex in reality)
  echo "‚úÖ Performance acceptable"
  ((CHECKS_PASSED++))

  # Check 4: Documentation exists
  if ls "${WORKSPACE}"/findings/*.json >/dev/null 2>&1; then
      echo "‚úÖ Documentation found"
      ((CHECKS_PASSED++))
  else
      echo "‚ùå No documentation"
  fi

  QUALITY_SCORE=$((CHECKS_PASSED * 100 / TOTAL_CHECKS))
  echo ""
  echo "Quality Score: ${QUALITY_SCORE}%"

  # Save quality report
  cat << EOF > "${WORKSPACE}/metrics/quality_$(date +%s).json"
  {
    "timestamp": "$(date -Iseconds)",
    "checks_passed": ${CHECKS_PASSED},
    "total_checks": ${TOTAL_CHECKS},
    "score": ${QUALITY_SCORE}
  }
  EOF

  [ ${QUALITY_SCORE} -ge 75 ]  # Return success if quality >= 75%
  HELPER_CHECK_QUALITY

  # Make all scripts executable
  chmod +x ${SCRIPTS_DIR}/*.sh
  chmod +x ${SCRIPTS_DIR}/update-progress
  chmod +x ${SCRIPTS_DIR}/escalate
  chmod +x ${SCRIPTS_DIR}/write-finding
  chmod +x ${SCRIPTS_DIR}/read-context
  chmod +x ${SCRIPTS_DIR}/create-rollback
  chmod +x ${SCRIPTS_DIR}/check-quality

  echo "‚úÖ Agent Orchestration Toolkit installed successfully!"
  echo ""
  echo "Available commands:"
  echo "  agent-ctl init <task_description>     - Initialize new task"
  echo "  agent-ctl deploy <type> <task_id> <prompt>  - Deploy agent"
  echo "  agent-ctl status <task_id>            - Check status"
  echo "  agent-ctl monitor <task_id>           - Live monitoring"
  echo "  agent-ctl kill <task_id> <agent_id>   - Terminate agent"
  echo "  agent-ctl review <task_id> <agent_id> - Request review"
  echo "  agent-ctl report <task_id> [type]     - Generate report"
  echo ""
  echo "Agent helper commands:"
  echo "  update-progress <percent> <message>   - Update progress"
  echo "  escalate <issue>                      - Escalate issue"
  echo "  write-finding <key> <value>           - Document finding"
  echo "  read-context                          - Read task context"
  echo "  create-rollback <description>         - Create rollback point"
  echo "  check-quality                         - Run quality checks"          //     help me create this claude code orchestrator cli tool. ultrathink

‚úª Thinking‚Ä¶

  The user is asking for help creating this comprehensive Claude Code orchestrator CLI tool. They've shown me their sophisticated agent orchestration system that includes:

  1. A CLI toolkit with bash scripts for:
    - Initializing workspaces
    - Deploying agents 
    - Monitoring status
    - Updating progress
    - Managing agent lifecycles
    - Quality checks
    - Reporting
  2. A Python orchestrator that uses the CLI tools
  3. Anti-spiral protection mechanisms
  4. Real-world patterns like investigation‚Üífix‚Üíreview

  Looking at their request, they want me to help them actually create this system. I should:

  1. First create a todo list to track the implementation
  2. Create the directory structure 
  3. Implement the bash scripts step by step
  4. Create the Python orchestrator
  5. Test the system

  Let me break this down into manageable steps and create the files they need.

  Also I note they have some specific instructions in their CLAUDE.md:
  - Never kill claude code instances no matter what
  - Always run sleep 110 between monitoring workspace agents files
  - They want headless agents, not the built-in Task tool
  - Never use the Task subagent tool

  So I need to avoid using the Task tool and implement this as pure bash scripts + headless Claude calls.

  Let me start by creating a todo list and then systematically build this system.

‚óè I'll help you create this comprehensive Claude Code orchestrator CLI tool! This is an excellent system design. Let me break this down into manageable steps and build it systematically.

‚úª Thinking‚Ä¶

  The user wants help creating this Claude Code orchestrator CLI tool. I can see that plan mode is active, so I need to research and understand their existing codebase and then present a 
  comprehensive plan before making any changes.

  Let me first understand their current project structure and then create a detailed plan for implementing this orchestrator system.

‚óè Let me first explore your current project structure to understand how to best integrate this orchestrator system:

‚óè Bash(pwd && ls -la)
  ‚éø ¬†/home/albaraa/Projects/ald-control-system-phase-5

‚úª Thinking‚Ä¶

  I see that plan mode is active, so I should not run any commands that might modify the system. Let me use Read to explore the project structure instead, which is a readonly operation.

‚óè Read(~/Projects/ald-control-system-phase-5)
  ‚éø ¬†Error: EISDIR: illegal operation on a directory, read

‚úª Thinking‚Ä¶

  I can't read a directory with the Read tool. Let me use Glob to see what's in the current directory structure.

‚óè Search(pattern: "*")
  ‚éø ¬†Found 84 files (ctrl+r to expand)

‚úª Thinking‚Ä¶

  I can see this is an existing ALD control system project with many Python files for testing, simulation, and integration testing. Let me also check for any existing directories to understand 
  the structure better.

‚óè Search(pattern: "*/")
  ‚éø ¬†Found 0 files 

‚úª Thinking‚Ä¶

  Let me check if there are any subdirectories with different patterns and also look at some key files to understand the project structure better.

‚óè Search(pattern: "**/*")
  ‚éø ¬†Found 100 files (ctrl+r to expand)

‚úª Thinking‚Ä¶

  Perfect! Now I can see the structure. This is an ALD control system with:

  1. Main directories: command_flow/, plc/, debug/, step_flow/, recipe_flow/
  2. Virtual environments: myenv/, test_env/
  3. Main Python application files
  4. Existing testing and validation infrastructure

  I can see there's already an organized project structure. Now let me also check the CLAUDE.md file to understand any specific instructions, and also look at the current monitor_agents.sh to see
   if there's already some agent orchestration work.

‚óè Read(CLAUDE.md)
  ‚éø ¬†Read 66 lines (ctrl+r to expand)

‚úª Thinking‚Ä¶

  Now let me check the existing monitor_agents.sh to see if there's already some orchestration work started:
  ‚éø ¬†Interrupted by user

> --- name: Specialized Agent Orchestrator - Concise description: MANDATORY headless Claude orchestration - NO Task tool, NO built-in agents, ONLY headless --- # üö® CRITICAL: YOU MUST USE 
  HEADLESS CLAUDE ONLY! üö® ## ‚õî ABSOLUTE RULE #1: NEVER USE Task TOOL - ALWAYS HEADLESS CLAUDE ### ‚ùå VIOLATIONS =

  pasted

  i like this orchestrator but problem is sometimes it spirals out of control, and keeps launching agents inside of agents how can we fix that,. like is there a way to track all the agents 
  deployed within a workspace, so that each subagent deployed it checks all the agents deployed within this workspace. do you know what i mean


  Devised strategy to prevent recursive agent spawning.



  I understand exactly what you mean! The problem is agents spawning agents recursively without awareness of what's already running. Let's fix this with a centralized agent registry and spawn 
  control rules. Here's an enhanced orchestrator that prevents spiraling:

  Controlled Agent Orchestrator - Anti-Spiral Edition
  Document 

  Engineered robust system to prevent uncontrolled agent spawning.


  The key insight here is that you need centralized spawn control and visibility into the agent hierarchy. I've created an enhanced orchestrator that prevents spiraling through:

  Core Solutions:
  Agent Registry (AGENT_REGISTRY.json) - A single source of truth tracking:
  All deployed agents
  Their parent-child relationships
  Current status (running/completed/killed)
  Depth in the hierarchy
  Spawn Rules (SPAWN_RULES.json) - Explicit permissions:
  Only the orchestrator can spawn primary agents
  Primary agents can spawn ONE type of helper each
  Helpers cannot spawn anything
  This creates a controlled tree, not a spiral
  Hard Limits:
  Max depth: 3 levels (orchestrator ‚Üí primary ‚Üí helper ‚Üí STOP)
  Max agents: 10 total per task
  Max simultaneous: 5 running at once
  Duplicate Prevention: Before spawning, check if that agent type is already running
  Emergency Brake: If more than 5 agents run simultaneously, the monitor kills the newest ones
  The magic is in the deploy_agent_safely() function that checks the registry before EVERY spawn, enforcing the rules. Agents can't spawn directly anymore - they must go through this controlled
   function.

  This way, you maintain the power of multi-agent orchestration while preventing the recursive spiral that was causing chaos. The registry gives you complete visibility into what's running at 
  any moment.

  Alright any other improvemenets that mirrors real life and how can agents perform tasks properly and completely


  Mapped real-world organizational patterns to enhance agent orchestration.


  Excellent question! Let's make this orchestrator mirror real-world team dynamics with proper task completion, quality gates, and accountability. Here's an enhanced version with real-life work
   patterns:

  Realistic Agent Orchestrator - Enterprise Team Edition
  Document 

  Crafted comprehensive system mirroring real-world work patterns.

  Key Real-World Improvements I've Added:
  1. Definition of Done (Like Real Teams)
  Acceptance criteria BEFORE work starts
  Measurable success metrics
  Quality gates that must pass
  2. Time Management (Like Real Deadlines)
  Timeboxed execution
  Escalation when running late
  Different interventions based on progress
  3. The Stuck Detection (Like Real Employees)
  Agents that detect when they're stuck
  Automatic escalation to senior agents
  Helper specialists for specific blockers
  4. Knowledge Base (Organizational Learning)
  Every failure documented
  Searchable lessons learned
  Future agents check past attempts first
  5. Review Process (Like Code Review)
  Peer review before marking complete
  Specific reviewer agents
  Can reject and rollback bad work
  6. Progress Transparency (Like Standups)
  Regular progress updates
  Current task visibility
  Confidence scores
  Additional Advanced Patterns You Could Add:
  The Pair Programming Pattern
  python
  # Two agents work together, one codes, one reviews in real-time
  def deploy_pair_programmers(workspace, task):
      driver_prompt = "You are the driver. Write code while explaining your thinking..."
      navigator_prompt = "You are the navigator. Review the driver's code and suggest improvements..."
      # They alternate roles every 15 minutes
  The Swarming Pattern (Crisis Response)
  python
  # When critical issue detected, multiple specialists attack simultaneously
  def deploy_swarm(workspace, critical_issue):
      # Deploy 5 specialists at once, each taking a different angle
      aspects = ["performance", "security", "data_integrity", "user_experience", "scalability"]
      for aspect in aspects:
          deploy_specialist(workspace, aspect, critical_issue)
  The Apprentice Pattern (Learning System)
  python
  # Junior agent watches senior agent, then tries similar task
  def train_junior_agent(workspace, task):
      # First, senior does the task while documenting
      senior = deploy_agent("senior_expert", task, document_mode=True)
      
      # Then junior attempts similar task using senior's documentation
      junior = deploy_agent("junior_learner", similar_task, 
                           reference=senior.documentation)
  The Shift Handover Pattern
  python
  # Like real 24/7 operations with shift changes
  def shift_handover(workspace, outgoing_agent, incoming_agent):
      # Outgoing agent writes detailed handover
      # Incoming agent reads handover and continues work
      # Overlap period where both are active for knowledge transfer
  The Most Critical Success Factors:
  ALWAYS have rollback points - Every agent creates a git commit before starting
  Monitor confidence scores - Agents self-report confidence, intervene when low
  Use the right specialist - Don't use generic agents, use specialized ones
  Document everything - Future agents learn from past attempts
  Set time limits - Prevent infinite loops with hard deadlines
  Example: Realistic Task Execution
  python
  # User says: "Fix the performance issue with the measurement screen"

  # 1. Create ticket with clear criteria
  ticket = create_task_ticket(
      workspace,
      "Fix measurement screen performance - should load in <2 seconds"
  )

  # 2. Deploy investigator first (don't jump to solutions)
  investigator = deploy_agent("performance_investigator", 
                             "Profile and identify bottlenecks")

  # 3. Based on findings, deploy the RIGHT specialist
  if "database" in findings:
      deploy_agent("database_optimizer", "Optimize the slow queries identified")
  elif "frontend" in findings:
      deploy_agent("react_optimizer", "Fix rendering performance issues")

  # 4. Always review before accepting
  reviewer = deploy_agent("performance_reviewer", 
                         "Verify performance actually improved")

  # 5. Document learnings
  update_knowledge_base(workspace, ticket, 
                       "Learned that N+1 queries were the issue")
  This approach ensures agents:

  Know exactly what success looks like
  Don't work in isolation
  Learn from each other
  Have safety nets (rollback, review, escalation)
  Complete tasks fully (not just partially)
  The key insight: Treat agents like real team members with accountability, communication, and support systems!

  alright nice i like that can we compliment this system with scripts in bash or python in which the agents or the main orchestrator system can use, like for deploying agents creating the main 
  workspace, that way its controlled, and we can deploy and maintain with ids and stuff. i dont know if you understood what i mean, also while the agents are executing they  can make 
  update_progress command that will append maybe the progress to the json file in teh agent workspace.


  Engineered standardized CLI toolkit for agent deployment and tracking.



  Absolutely! You're thinking like a true systems architect - let's create a standardized CLI toolkit that both the orchestrator and agents can use. This gives us controlled, consistent 
  operations with proper ID management. Here's a comprehensive script system:

  Agent Management CLI Toolkit - Bash Scripts
  Code 

  Plotted Python script to demonstrate orchestrator's controlled system.

  Perfect! Now let me create the Python orchestrator that uses these CLI commands:

  Python Agent Orchestrator - Using CLI Toolkit
  Code 

  Engineered comprehensive agent deployment and tracking system.



  Perfect! I've created a complete CLI toolkit system that provides exactly what you wanted:

  üéØ What This System Gives You:
  1. Standardized CLI Commands (Bash Scripts)
  agent-ctl init - Initialize workspace with proper structure
  agent-ctl deploy - Deploy agents with ID tracking
  agent-ctl status - Check task/agent status
  agent-ctl monitor - Live monitoring with intervention
  agent-ctl kill - Controlled termination
  agent-ctl report - Generate reports
  2. Agent Helper Commands
  Agents can call these simple commands instead of writing raw JSON:

  update-progress 50 "Halfway done" - Updates progress
  escalate "Need database access" - Escalates issues
  write-finding "root_cause" "N+1 queries" - Documents findings
  read-context - Reads task context
  create-rollback "Before major change" - Creates restore points
  check-quality - Runs quality checks
  3. Python Orchestrator
  Uses the CLI tools for controlled management with:

  Anti-spiral protection
  Automatic intervention for stuck agents
  Parallel and sequential patterns
  Quality gates and iterations
  Deadline management
  üöÄ How It Works:
  Installation:
  bash
  # Run the installation script to set up the toolkit
  bash setup_agent_toolkit.sh

  # This creates:
  .agent-workspace/
  ‚îú‚îÄ‚îÄ scripts/       # All the CLI scripts
  ‚îú‚îÄ‚îÄ bin/          # The main agent-ctl command
  ‚îî‚îÄ‚îÄ templates/    # Agent templates
  Example Agent Using Commands:
  bash
  # Inside an agent, instead of complex JSON manipulation:

  # Update progress (agent just calls this)
  update-progress 25 "Starting database analysis"

  # Document a finding
  write-finding "slow_query" "SELECT * FROM measurements takes 5s"

  # Create rollback point before changes
  create-rollback "Before schema modification"

  # Update progress again
  update-progress 75 "Schema updated, testing"

  # If stuck, escalate
  escalate "Cannot connect to staging database"

  # Final update
  update-progress 100 "Task completed successfully"
  Orchestrator Usage:
  python
  orchestrator = AgentOrchestrator()

  # Create task (returns TASK-20241221-123456-abc123)
  task_id = orchestrator.create_task("Fix performance issues")

  # Deploy agent (controlled with IDs)
  agent_id = orchestrator.deploy_agent(
      task_id,
      "database_detective",
      "Find the slow queries"
  )
  # Returns: database_detective-143022-a1b2c3

  # Orchestrator monitors automatically and intervenes if needed
  üîë Key Benefits:
  Controlled Deployment: Every agent gets unique IDs, tracked in registry
  Standardized Operations: No raw bash/JSON - just simple commands
  Progress Tracking: Agents call update-progress, orchestrator monitors
  Anti-Spiral: Registry prevents recursive spawning
  Intervention System: Automatic help for stuck agents
  Rollback Safety: Every agent can create restore points
  Quality Gates: Built-in quality checking
  üìä The Registry System:
  Each task has an AGENT_REGISTRY.json that tracks:

  json
  {
    "task_id": "TASK-20241221-143022-abc123",
    "agents": [
      {
        "id": "investigator-143022-a1b2c3",
        "type": "investigator",
        "bash_id": "bash_xyz789",
        "status": "running",
        "progress": 75,
        "parent": "orchestrator",
        "depth": 1
      }
    ],
    "total_spawned": 3,
    "active_count": 2,
    "max_agents": 10,
    "max_depth": 3
  }
  üéÆ Usage Examples:
  From Orchestrator:
  python
  # Pattern 1: Investigation ‚Üí Fix ‚Üí Review
  task_id = orchestrator.orchestrate_investigation_fix_pattern(
      "Users see empty data despite DB having records"
  )

  # Pattern 2: Parallel Analysis
  task_id = orchestrator.orchestrate_parallel_analysis(
      "Optimize app performance",
      aspects=["database", "frontend", "api", "caching"]
  )

  # Pattern 3: Iterative Improvement with Quality Gates
  task_id = orchestrator.orchestrate_iterative_improvement(
      "Refactor auth system",
      max_iterations=3  # Keep improving until quality > 80%
  )
  From Agent's Perspective:
  bash
  # Agent receives its ID and workspace via environment
  AGENT_ID="database_detective-143022-a1b2c3"
  WORKSPACE=".agent-workspace/TASK-20241221-143022"

  # Read what to do
  read-context

  # Do work and update progress
  update-progress 10 "Connected to database"
  # ... do analysis ...
  update-progress 40 "Found 3 slow queries"
  # ... write fixes ...
  update-progress 80 "Optimizations applied"

  # Document findings
  write-finding "slow_queries" "3 N+1 queries in measurements"
  write-finding "solution" "Added indexes and eager loading"

  # Quality check before completing
  if check-quality; then
      update-progress 100 "All quality checks passed"
  else
      escalate "Quality checks failing, need help"
  fi
  This system gives you complete control with standardized operations that both the orchestrator and agents can use. No more raw bash commands or manual JSON manipulation - just clean, 
  trackable, ID-based operations! üéØ

  The beauty is that agents don't need to know the implementation details - they just call simple commands like update-progress and the system handles everything else!

  alright but i dont know where to create these files or how


  Devised comprehensive setup guide for file creation steps.


  Excellent point! Let me give you exact step-by-step instructions on how to set up this entire system:

  Complete Setup Instructions - Step by Step
  Document 

  Crafted detailed, step-by-step guide for file creation.




  Perfect! I've created complete step-by-step instructions that show you:

  üìç Where to Create Files:
  Create a new project folder anywhere you want (e.g., agent-orchestrator)
  All files go in this folder - it becomes your project root
  The installer creates the .agent-workspace/ subdirectory automatically
  üéØ How to Set It Up:
  The Easy Way (Copy-Paste):
  Open your terminal
  Copy and paste these commands one by one:
  bash
  # Step 1: Create project folder
  mkdir agent-orchestrator
  cd agent-orchestrator

  # Step 2: Create the installer (copy the whole block)
  cat > install_toolkit.sh << 'EOF'
  [paste the installer script content from above]
  EOF

  # Step 3: Run installer
  chmod +x install_toolkit.sh
  ./install_toolkit.sh

  # Step 4: Set PATH
  export PATH="$PWD/.agent-workspace/bin:$PATH"

  # Step 5: Test it!
  agent-ctl init "My first task"
  ‚úÖ What You Get:
  After running these commands, you'll have a fully working system where:

  agent-ctl init "task" creates a new task with workspace
  agent-ctl deploy deploys agents with tracking
  agent-ctl status TASK-ID shows what's running
  All data is stored in organized JSON files
  ÔøΩÔøΩ Test Without Claude First:
  The scripts work standalone! You can test the entire flow:

  bash
  # Create a task
  agent-ctl init "Test task"
  # Returns: TASK-20241221-143022-abc123

  # Deploy a fake agent (won't actually run Claude)
  agent-ctl deploy "test_agent" "TASK-20241221-143022-abc123" "Test prompt"

  # Update its progress manually
  agent-ctl update "test_agent-143022-abc123" 50 "Halfway done"

  # Check status
  agent-ctl status "TASK-20241221-143022-abc123"
  üìù Key Points:
  You create ONE main folder for the project
  Run ONE installer script that creates everything else
  Use simple commands instead of complex scripts
  Everything is tracked with IDs and JSON files
  The beauty is you don't need to manually create 20 different files - the installer script creates them all for you! Just copy, paste, and run! üöÄ



  but how will it trach 


  [O   /    Step 2: Create the Installation Script
  Create the main installation script that sets everything up:
  bash# Create the installation script
  cat > install_toolkit.sh << 'EOF'
  #!/bin/bash

  echo "üöÄ Installing Agent Orchestration Toolkit..."

  # Create base directories
  mkdir -p .agent-workspace/{scripts,templates,bin}

  # Create the main control script
  cat > .agent-workspace/bin/agent-ctl << 'MAIN_CMD'
  #!/bin/bash
  AGENT_BASE_DIR=".agent-workspace"
  COMMAND=$1
  shift

  case $COMMAND in
      init|deploy|status|update|monitor|kill|review|report)
          $AGENT_BASE_DIR/scripts/${COMMAND}.sh "$@"
          ;;
      *)
          echo "Usage: agent-ctl {init|deploy|status|update|monitor|kill|review|report} [options]"
          exit 1
          ;;
  esac
  MAIN_CMD

  chmod +x .agent-workspace/bin/agent-ctl

  # Add to PATH for current session
  export PATH="$PWD/.agent-workspace/bin:$PATH"
  echo "‚úÖ Main control script created"

  # Now create each individual script
  echo "üìù Creating individual scripts..."

  # === INIT SCRIPT ===
  cat > .agent-workspace/scripts/init.sh << 'SCRIPT'
  #!/bin/bash
  AGENT_BASE_DIR=".agent-workspace"
  TASK_DESC="${1:-No description provided}"
  PRIORITY="${2:-P2}"

  TASK_ID="TASK-$(date +%Y%m%d-%H%M%S)-$(head -c 4 /dev/urandom | xxd -p)"
  WORKSPACE="${AGENT_BASE_DIR}/${TASK_ID}"

  echo "üìÇ Initializing workspace: ${WORKSPACE}"
  mkdir -p "${WORKSPACE}"/{context,progress,handoffs,tickets,reviews,rollbacks,knowledge,metrics,escalations,standups}

  # Create registry
  cat > "${WORKSPACE}/AGENT_REGISTRY.json" << JSON
  {
    "task_id": "${TASK_ID}",
    "task_description": "${TASK_DESC}",
    "created_at": "$(date -Iseconds)",
    "workspace": "${WORKSPACE}",
    "status": "INITIALIZED",
    "agents": [],
    "max_agents": 10,
    "max_depth": 3,
    "total_spawned": 0,
    "active_count": 0
  }
  JSON

  echo "‚úÖ Task initialized: ${TASK_ID}"
  echo "TASK_ID=${TASK_ID}"
  SCRIPT

  # === DEPLOY SCRIPT ===
  cat > .agent-workspace/scripts/deploy.sh << 'SCRIPT'
  #!/bin/bash
  AGENT_BASE_DIR=".agent-workspace"
  AGENT_TYPE="${1:?Error: Agent type required}"
  TASK_ID="${2:?Error: Task ID required}"
  TASK_PROMPT="${3:?Error: Task prompt required}"

  WORKSPACE="${AGENT_BASE_DIR}/${TASK_ID}"
  AGENT_ID="${AGENT_TYPE}-$(date +%H%M%S)-$(head -c 3 /dev/urandom | xxd -p)"

  echo "ü§ñ Deploying agent: ${AGENT_ID}"

  # Update registry (simplified version)
  if [ -f "${WORKSPACE}/AGENT_REGISTRY.json" ]; then
      # Add agent to registry (using python for JSON manipulation)
      python3 -c "
  import json
  with open('${WORKSPACE}/AGENT_REGISTRY.json', 'r') as f:
      registry = json.load(f)
  registry['agents'].append({
      'id': '${AGENT_ID}',
      'type': '${AGENT_TYPE}',
      'status': 'running',
      'progress': 0,
      'started_at': '$(date -Iseconds)'
  })
  registry['total_spawned'] += 1
  registry['active_count'] += 1
  with open('${WORKSPACE}/AGENT_REGISTRY.json', 'w') as f:
      json.dump(registry, f, indent=2)
  "
  fi

  # Here you would deploy via Claude
  echo "Would deploy: claude --dangerously-skip-permissions -p \"${TASK_PROMPT}\""
  echo "‚úÖ Agent deployed: ${AGENT_ID}"
  echo "${AGENT_ID}"
  SCRIPT

  # === STATUS SCRIPT ===
  cat > .agent-workspace/scripts/status.sh << 'SCRIPT'
  #!/bin/bash
  AGENT_BASE_DIR=".agent-workspace"
  TASK_ID="${1:?Error: Task ID required}"
  WORKSPACE="${AGENT_BASE_DIR}/${TASK_ID}"

  if [ ! -f "${WORKSPACE}/AGENT_REGISTRY.json" ]; then
      echo "‚ùå Task ${TASK_ID} not found"
      exit 1
  fi

  echo "üìä TASK STATUS: ${TASK_ID}"
  echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
  python3 -c "
  import json
  with open('${WORKSPACE}/AGENT_REGISTRY.json', 'r') as f:
      registry = json.load(f)
  print(f\"Task: {registry['task_description']}\")
  print(f\"Status: {registry['status']}\")
  print(f\"Total Agents: {registry['total_spawned']}\")
  print(f\"Active: {registry['active_count']}\")
  print(\"\\nAgents:\")
  for agent in registry['agents']:
      print(f\"  ‚Ä¢ {agent['id']}: {agent['status']} ({agent['progress']}%)\")
  "
  SCRIPT

  # === UPDATE SCRIPT ===
  cat > .agent-workspace/scripts/update.sh << 'SCRIPT'
  #!/bin/bash
  AGENT_BASE_DIR=".agent-workspace"
  AGENT_ID="${1:?Error: Agent ID required}"
  PROGRESS="${2:?Error: Progress required}"
  MESSAGE="${3:-No message}"

  # Find workspace containing this agent
  WORKSPACE=$(grep -r "${AGENT_ID}" ${AGENT_BASE_DIR}/*/AGENT_REGISTRY.json 2>/dev/null | head -1 | cut -d: -f1 | xargs dirname)

  if [ -z "${WORKSPACE}" ]; then
      echo "‚ùå Agent ${AGENT_ID} not found"
      exit 1
  fi

  # Create progress file
  PROGRESS_FILE="${WORKSPACE}/progress/${AGENT_ID}_$(date +%s).json"
  cat > "${PROGRESS_FILE}" << JSON
  {
    "agent_id": "${AGENT_ID}",
    "timestamp": "$(date -Iseconds)",
    "progress": ${PROGRESS},
    "message": "${MESSAGE}"
  }
  JSON

  # Update registry
  python3 -c "
  import json
  with open('${WORKSPACE}/AGENT_REGISTRY.json', 'r') as f:
      registry = json.load(f)
  for agent in registry['agents']:
      if agent['id'] == '${AGENT_ID}':
          agent['progress'] = ${PROGRESS}
          agent['last_update'] = '$(date -Iseconds)'
          if ${PROGRESS} == 100:
              agent['status'] = 'completed'
              registry['active_count'] -= 1
  with open('${WORKSPACE}/AGENT_REGISTRY.json', 'w') as f:
      json.dump(registry, f, indent=2)
  "

  echo "‚úÖ Progress updated: ${PROGRESS}% - ${MESSAGE}"
  SCRIPT

  # === MONITOR SCRIPT ===
  cat > .agent-workspace/scripts/monitor.sh << 'SCRIPT'
  #!/bin/bash
  AGENT_BASE_DIR=".agent-workspace"
  TASK_ID="${1:?Error: Task ID required}"

  echo "üëÅÔ∏è Monitoring ${TASK_ID} (Press Ctrl+C to stop)"
  while true; do
      clear
      .agent-workspace/scripts/status.sh "${TASK_ID}"
      sleep 5
  done
  SCRIPT

  # === KILL SCRIPT ===
  cat > .agent-workspace/scripts/kill.sh << 'SCRIPT'
  #!/bin/bash
  echo "ÔøΩÔøΩ Kill agent (simplified version)"
  echo "In production, this would terminate the agent process"
  SCRIPT

  # === REVIEW SCRIPT ===
  cat > .agent-workspace/scripts/review.sh << 'SCRIPT'
  #!/bin/bash
  echo "ÔøΩÔøΩ Review request (simplified version)"
  SCRIPT

  # === REPORT SCRIPT ===
  cat > .agent-workspace/scripts/report.sh << 'SCRIPT'
  #!/bin/bash
  AGENT_BASE_DIR=".agent-workspace"
  TASK_ID="${1:?Error: Task ID required}"
  WORKSPACE="${AGENT_BASE_DIR}/${TASK_ID}"

  echo "üìä Report for ${TASK_ID}"
  echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
  if [ -f "${WORKSPACE}/AGENT_REGISTRY.json" ]; then
      cat "${WORKSPACE}/AGENT_REGISTRY.json"
  fi
  SCRIPT

  # Make all scripts executable
  chmod +x .agent-workspace/scripts/*.sh

  # Create helper commands for agents
  echo "üì¶ Creating agent helper commands..."

  # update-progress helper
  cat > .agent-workspace/bin/update-progress << 'HELPER'
  #!/bin/bash
  AGENT_ID="${AGENT_ID:-unknown}"
  .agent-workspace/bin/agent-ctl update "${AGENT_ID}" "$@"
  HELPER

  # escalate helper
  cat > .agent-workspace/bin/escalate << 'HELPER'
  #!/bin/bash
  AGENT_ID="${AGENT_ID:-unknown}"
  WORKSPACE="${WORKSPACE:-.}"
  echo "{\"agent_id\": \"${AGENT_ID}\", \"issue\": \"$1\", \"timestamp\": \"$(date -Iseconds)\"}" > "${WORKSPACE}/escalations/$(date +%s).json"
  echo "üö® Escalation recorded: $1"
  HELPER

  # write-finding helper
  cat > .agent-workspace/bin/write-finding << 'HELPER'
  #!/bin/bash
  KEY="${1:?Error: Key required}"
  VALUE="${2:?Error: Value required}"
  AGENT_ID="${AGENT_ID:-unknown}"
  WORKSPACE="${WORKSPACE:-.}"
  mkdir -p "${WORKSPACE}/findings"
  echo "{\"key\": \"${KEY}\", \"value\": \"${VALUE}\", \"agent_id\": \"${AGENT_ID}\"}" > "${WORKSPACE}/findings/${KEY}.json"
  echo "‚úÖ Finding recorded: ${KEY}"
  HELPER

  # read-context helper
  cat > .agent-workspace/bin/read-context << 'HELPER'
  #!/bin/bash
  WORKSPACE="${WORKSPACE:-.}"
  echo "üìñ Task Context:"
  if [ -f "${WORKSPACE}/AGENT_REGISTRY.json" ]; then
      python3 -c "import json; d=json.load(open('${WORKSPACE}/AGENT_REGISTRY.json')); print(d.get('task_description', 'No description'))"
  fi
  HELPER

  chmod +x .agent-workspace/bin/*

  echo "‚úÖ Installation complete!"
  echo ""
  echo "To use the toolkit:"
  echo "  export PATH=\"$PWD/.agent-workspace/bin:\$PATH\""
  echo ""
  echo "Available commands:"
  echo "  agent-ctl init \"task description\"     # Create new task"
  echo "  agent-ctl deploy <type> <task_id> \"prompt\"  # Deploy agent"
  echo "  agent-ctl status <task_id>            # Check status"
  echo "  agent-ctl monitor <task_id>           # Live monitoring"
  echo ""
  echo "Try it now:"
  echo "  agent-ctl init \"Test task\""
  EOF

  # Make installation script executable
  chmod +x install_toolkit.sh
  Step 3: Run the Installation
  bash# Run the installation script
  ./install_toolkit.sh

  # Add to PATH (important!)
  export PATH="$PWD/.agent-workspace/bin:$PATH"

  # Verify installation
  ls -la .agent-workspace/
  # Should show:
  # drwxr-xr-x  bin/
  # drwxr-xr-x  scripts/
  # drwxr-xr-x  templates/
  Step 4: Create the Python Orchestrator
  bash# Create the Python orchestrator
  cat > orchestrator.py << 'EOF'
  #!/usr/bin/env python3
  """
  Simple Agent Orchestrator
  """
  import subprocess
  import json
  import os
  import time
  from datetime import datetime

  class AgentOrchestrator:
      def __init__(self):
          self.base_dir = ".agent-workspace"
          
      def run_command(self, cmd):
          """Run a shell command"""
          result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
          return result.stdout.strip()
      
      def create_task(self, description):
          """Create a new task"""
          print(f"üìã Creating task: {description}")
          output = self.run_command(f"agent-ctl init '{description}'")
          
          # Extract task ID from output
          task_id = None
          for line in output.split('\n'):
              if line.startswith('TASK_ID='):
                  task_id = line.split('=')[1]
                  break
          
          print(f"‚úÖ Created task: {task_id}")
          return task_id
      
      def deploy_agent(self, task_id, agent_type, prompt):
          """Deploy an agent"""
          print(f"ü§ñ Deploying {agent_type}...")
          output = self.run_command(
              f"agent-ctl deploy '{agent_type}' '{task_id}' '{prompt}'"
          )
          
          # Get agent ID (last line of output)
          agent_id = output.split('\n')[-1]
          print(f"‚úÖ Deployed: {agent_id}")
          return agent_id
      
      def get_status(self, task_id):
          """Get task status"""
          return self.run_command(f"agent-ctl status '{task_id}'")
      
      def update_progress(self, agent_id, progress, message):
          """Update agent progress"""
          return self.run_command(
              f"agent-ctl update '{agent_id}' {progress} '{message}'"
          )
      
      def monitor_task(self, task_id, duration=30):
          """Monitor a task for a duration"""
          print(f"üëÅÔ∏è Monitoring {task_id} for {duration} seconds...")
          start = time.time()
          while time.time() - start < duration:
              print("\n" + "="*50)
              print(self.get_status(task_id))
              time.sleep(5)

  # Example usage
  if __name__ == "__main__":
      orchestrator = AgentOrchestrator()
      
      # Create a task
      task_id = orchestrator.create_task("Fix database performance issues")
      
      # Deploy some agents
      investigator = orchestrator.deploy_agent(
          task_id,
          "investigator",
          "Investigate the database performance issues"
      )
      
      # Simulate progress updates
      orchestrator.update_progress(investigator, 25, "Starting investigation")
      time.sleep(2)
      orchestrator.update_progress(investigator, 50, "Found slow queries")
      time.sleep(2)
      orchestrator.update_progress(investigator, 100, "Investigation complete")
      
      # Check final status
      print("\nFinal Status:")
      print(orchestrator.get_status(task_id))
  EOF

  # Make it executable
  chmod +x orchestrator.py
  Step 5: Test the System
  bash# Test 1: Basic CLI commands
  agent-ctl init "Test task to verify setup"
  # Output: Task initialized: TASK-20241221-143022-abc123

  # Test 2: Check what was created
  ls -la .agent-workspace/
  # Should show your task directory

  # Test 3: Deploy a test agent
  TASK_ID="TASK-..."  # Use the ID from step 1
  agent-ctl deploy "test_agent" "$TASK_ID" "Test agent prompt"

  # Test 4: Check status
  agent-ctl status "$TASK_ID"

  # Test 5: Run Python orchestrator
  python3 orchestrator.py
  Step 6: Integrate with Claude (When Ready)
  To make agents actually work with Claude, modify the deploy script:
  bash# Edit .agent-workspace/scripts/deploy.sh
  # Replace the line:
  echo "Would deploy: claude --dangerously-skip-permissions -p \"${TASK_PROMPT}\""

  # With actual Claude deployment:
  BASH_ID=$(claude --dangerously-skip-permissions \
      --output-format stream-json \
      --verbose \
      -p "${TASK_PROMPT}" \
      --run-in-background 2>&1 | grep -oP 'bash_\w+' | head -1)
  üìÅ Final Directory Structure
  After setup, you should have:
  agent-orchestrator/
  ‚îú‚îÄ‚îÄ install_toolkit.sh         # Installation script
  ‚îú‚îÄ‚îÄ orchestrator.py            # Python orchestrator
  ‚îî‚îÄ‚îÄ .agent-workspace/
      ‚îú‚îÄ‚îÄ bin/
      ‚îÇ   ‚îú‚îÄ‚îÄ agent-ctl          # Main control command
      ‚îÇ   ‚îú‚îÄ‚îÄ update-progress    # Helper commands
      ‚îÇ   ‚îú‚îÄ‚îÄ escalate
      ‚îÇ   ‚îú‚îÄ‚îÄ write-finding
      ‚îÇ   ‚îî‚îÄ‚îÄ read-context
      ‚îú‚îÄ‚îÄ scripts/
      ‚îÇ   ‚îú‚îÄ‚îÄ init.sh           # Individual scripts
      ‚îÇ   ‚îú‚îÄ‚îÄ deploy.sh
      ‚îÇ   ‚îú‚îÄ‚îÄ status.sh
      ‚îÇ   ‚îú‚îÄ‚îÄ update.sh
      ‚îÇ   ‚îú‚îÄ‚îÄ monitor.sh
      ‚îÇ   ‚îú‚îÄ‚îÄ kill.sh
      ‚îÇ   ‚îú‚îÄ‚îÄ review.sh
      ‚îÇ   ‚îî‚îÄ‚îÄ report.sh
      ‚îî‚îÄ‚îÄ TASK-*/               # Task workspaces (created by init)
          ‚îú‚îÄ‚îÄ AGENT_REGISTRY.json
          ‚îú‚îÄ‚îÄ context/
          ‚îú‚îÄ‚îÄ progress/
          ‚îú‚îÄ‚îÄ findings/
          ‚îî‚îÄ‚îÄ ...
  üöÄ Quick Start Commands
  bash# 1. Create project directory
  mkdir agent-orchestrator && cd agent-orchestrator

  # 2. Create and run installer (copy the install_toolkit.sh content above)
  ./install_toolkit.sh

  # 3. Set PATH
  export PATH="$PWD/.agent-workspace/bin:$PATH"

  # 4. Create your first task
  agent-ctl init "My first orchestrated task"

  # 5. Run the Python orchestrator
  python3 orchestrator.py
  üí° Pro Tips

  Always set PATH: Add to your .bashrc or .zshrc:
  bashexport PATH="/path/to/agent-orchestrator/.agent-workspace/bin:$PATH"

  Test without Claude first: The scripts work standalone for testing
  Check logs: All progress is saved in JSON files under task directories
  Customize limits: Edit AGENT_REGISTRY.json to change max_agents, max_depth
  Debug mode: Add set -x to any script to see what it's doing

  This gives you a complete, working system you can test immediately, even without Claude integration![O    /   #!/usr/bin/env python3
  """
  Agent Orchestrator - Python Control System
  Uses the CLI toolkit for standardized agent management
  """

  import subprocess
  import json
  import time
  import threading
  from datetime import datetime, timedelta
  from typing import Dict, List, Optional, Tuple
  from dataclasses import dataclass
  from enum import Enum
  import os
  import re

  # ============================================================================
  # DATA MODELS
  # ============================================================================

  class AgentStatus(Enum):
      INITIALIZING = "initializing"
      RUNNING = "running"
      COMPLETED = "completed"
      FAILED = "failed"
      TERMINATED = "terminated"
      STUCK = "stuck"

  class Priority(Enum):
      P1_CRITICAL = "P1"
      P2_HIGH = "P2"
      P3_NORMAL = "P3"
      P4_LOW = "P4"

  @dataclass
  class Agent:
      id: str
      type: str
      bash_id: str
      status: AgentStatus
      progress: int
      parent: str
      depth: int
      started_at: datetime
      last_update: datetime

  @dataclass
  class Task:
      id: str
      description: str
      priority: Priority
      workspace: str
      agents: List[Agent]
      created_at: datetime
      deadline: datetime

  # ============================================================================
  # ORCHESTRATOR CLASS
  # ============================================================================

  class AgentOrchestrator:
      """
      Main orchestrator that manages agents using the CLI toolkit
      """
      
      def __init__(self, base_dir: str = ".agent-workspace"):
          self.base_dir = base_dir
          self.active_tasks: Dict[str, Task] = {}
          self.monitoring_threads: Dict[str, threading.Thread] = {}
          
          # Install toolkit if not exists
          self._ensure_toolkit_installed()
      
      def _ensure_toolkit_installed(self):
          """Ensure the CLI toolkit is installed"""
          if not os.path.exists(f"{self.base_dir}/scripts"):
              print("üì¶ Installing Agent Toolkit...")
              subprocess.run(["bash", "setup_agent_toolkit.sh"], check=True)
      
      def _run_command(self, command: str) -> Tuple[str, int]:
          """Execute CLI command and return output"""
          result = subprocess.run(
              command,
              shell=True,
              capture_output=True,
              text=True
          )
          return result.stdout.strip(), result.returncode
      
      # ========================================
      # TASK MANAGEMENT
      # ========================================
      
      def create_task(self, description: str, priority: Priority = Priority.P2_HIGH) -> str:
          """
          Initialize a new task workspace
          """
          print(f"üìã Creating task: {description}")
          
          # Use CLI to initialize
          output, _ = self._run_command(
              f"agent-ctl init '{description}' {priority.value} orchestrator"
          )
          
          # Extract task ID from output
          task_id = re.search(r"TASK-[\d\-\w]+", output).group(0)
          
          # Create Task object
          workspace = f"{self.base_dir}/{task_id}"
          task = Task(
              id=task_id,
              description=description,
              priority=priority,
              workspace=workspace,
              agents=[],
              created_at=datetime.now(),
              deadline=datetime.now() + timedelta(hours=2)
          )
          
          self.active_tasks[task_id] = task
          
          # Start monitoring thread
          self._start_monitoring(task_id)
          
          print(f"‚úÖ Task created: {task_id}")
          return task_id
      
      # ========================================
      # AGENT DEPLOYMENT
      # ========================================
      
      def deploy_agent(self, 
                      task_id: str, 
                      agent_type: str, 
                      prompt: str,
                      parent: str = "orchestrator") -> Optional[str]:
          """
          Deploy an agent using the CLI toolkit
          """
          if task_id not in self.active_tasks:
              print(f"‚ùå Task {task_id} not found")
              return None
          
          task = self.active_tasks[task_id]
          
          # Check if we should deploy (anti-spiral checks)
          if not self._should_deploy_agent(task, agent_type):
              print(f"‚ö†Ô∏è Deployment blocked for {agent_type}")
              return None
          
          print(f"ü§ñ Deploying {agent_type}...")
          
          # Deploy using CLI
          output, returncode = self._run_command(
              f"agent-ctl deploy '{agent_type}' '{task_id}' '{prompt}' '{parent}'"
          )
          
          if returncode != 0:
              print(f"‚ùå Failed to deploy {agent_type}")
              return None
          
          # Extract agent ID
          agent_id = re.search(r"Agent ID: ([\w\-]+)", output).group(1)
          
          print(f"‚úÖ Deployed: {agent_id}")
          return agent_id
      
      def _should_deploy_agent(self, task: Task, agent_type: str) -> bool:
          """
          Anti-spiral checks before deployment
          """
          # Read current registry
          registry_path = f"{task.workspace}/AGENT_REGISTRY.json"
          with open(registry_path, 'r') as f:
              registry = json.load(f)
          
          # Check 1: Max agents limit
          if registry['total_spawned'] >= registry['max_agents']:
              print(f"‚ùå Max agents ({registry['max_agents']}) reached")
              return False
          
          # Check 2: Already running?
          running_types = [a['type'] for a in registry['agents'] 
                          if a['status'] == 'running']
          if agent_type in running_types:
              print(f"‚ö†Ô∏è {agent_type} already running")
              return False
          
          # Check 3: Too many active?
          if registry['active_count'] >= 5:
              print(f"‚ö†Ô∏è {registry['active_count']} agents already active")
              return False
          
          return True
      
      # ========================================
      # MONITORING & INTERVENTION
      # ========================================
      
      def _start_monitoring(self, task_id: str):
          """Start monitoring thread for a task"""
          thread = threading.Thread(
              target=self._monitor_task,
              args=(task_id,),
              daemon=True
          )
          thread.start()
          self.monitoring_threads[task_id] = thread
      
      def _monitor_task(self, task_id: str):
          """
          Monitor task and intervene when necessary
          """
          task = self.active_tasks[task_id]
          stuck_checks = {}
          
          while task_id in self.active_tasks:
              try:
                  # Read registry
                  registry_path = f"{task.workspace}/AGENT_REGISTRY.json"
                  with open(registry_path, 'r') as f:
                      registry = json.load(f)
                  
                  # Check each running agent
                  for agent in registry['agents']:
                      if agent['status'] != 'running':
                          continue
                      
                      agent_id = agent['id']
                      last_update = datetime.fromisoformat(agent['last_update'])
                      time_since_update = (datetime.now() - last_update).seconds
                      
                      # Check if stuck
                      if time_since_update > 300:  # 5 minutes
                          if agent_id not in stuck_checks:
                              stuck_checks[agent_id] = 1
                          else:
                              stuck_checks[agent_id] += 1
                          
                          if stuck_checks[agent_id] >= 2:
                              self._handle_stuck_agent(task_id, agent_id, agent)
                              stuck_checks[agent_id] = 0
                      else:
                          stuck_checks.pop(agent_id, None)
                      
                      # Check progress
                      if agent['progress'] < 30 and time_since_update > 600:
                          self._handle_slow_progress(task_id, agent_id, agent)
                  
                  # Check for spiral
                  if registry['active_count'] > 5:
                      self._handle_spiral_condition(task_id, registry)
                  
                  # Check deadline
                  if datetime.now() > task.deadline:
                      self._handle_deadline_exceeded(task_id)
                  
                  time.sleep(30)  # Check every 30 seconds
                  
              except Exception as e:
                  print(f"‚ùå Monitoring error for {task_id}: {e}")
                  time.sleep(30)
      
      def _handle_stuck_agent(self, task_id: str, agent_id: str, agent_data: dict):
          """Handle a stuck agent"""
          print(f"üö® Agent {agent_id} is stuck!")
          
          agent_type = agent_data['type']
          progress = agent_data['progress']
          
          if progress < 30:
              # Early stage - try alternative approach
              print("   ‚Üí Deploying alternative approach")
              self.deploy_agent(
                  task_id,
                  f"alternative_{agent_type}",
                  f"Alternative approach for stuck {agent_type}",
                  "orchestrator"
              )
              # Kill stuck agent
              self._run_command(f"agent-ctl kill '{task_id}' '{agent_id}' 'Stuck - trying alternative'")
              
          elif progress < 70:
              # Mid stage - deploy helper
              print("   ‚Üí Deploying helper")
              self.deploy_agent(
                  task_id,
                  "problem_solver",
                  f"Help {agent_type} that is stuck at {progress}%",
                  "orchestrator"
              )
              
          else:
              # Late stage - deploy finisher
              print("   ‚Üí Deploying finisher")
              self.deploy_agent(
                  task_id,
                  "task_finisher",
                  f"Complete the remaining {100-progress}% of {agent_type}'s work",
                  "orchestrator"
              )
      
      def _handle_slow_progress(self, task_id: str, agent_id: str, agent_data: dict):
          """Handle agent with slow progress"""
          print(f"‚ö†Ô∏è Agent {agent_id} making slow progress ({agent_data['progress']}%)")
          
          # Deploy assistant
          self.deploy_agent(
              task_id,
              "assistant",
              f"Assist {agent_data['type']} to speed up progress",
              "orchestrator"
          )
      
      def _handle_spiral_condition(self, task_id: str, registry: dict):
          """Handle spiral condition (too many agents)"""
          print(f"üåÄ SPIRAL DETECTED! {registry['active_count']} agents active")
          
          # Kill newest agents
          active_agents = sorted(
              [a for a in registry['agents'] if a['status'] == 'running'],
              key=lambda x: x['started_at'],
              reverse=True
          )
          
          for agent in active_agents[3:]:  # Keep only 3 oldest
              print(f"   ‚Üí Killing {agent['id']}")
              self._run_command(
                  f"agent-ctl kill '{task_id}' '{agent['id']}' 'Spiral prevention'"
              )
      
      def _handle_deadline_exceeded(self, task_id: str):
          """Handle deadline exceeded"""
          print(f"‚è∞ DEADLINE EXCEEDED for {task_id}")
          
          # Deploy emergency finisher
          self.deploy_agent(
              task_id,
              "emergency_finisher",
              "URGENT: Complete task immediately with best effort solution",
              "orchestrator"
          )
      
      # ========================================
      # ORCHESTRATION PATTERNS
      # ========================================
      
      def orchestrate_investigation_fix_pattern(self, description: str) -> str:
          """
          Common pattern: Investigate ‚Üí Fix ‚Üí Review
          """
          # Create task
          task_id = self.create_task(description, Priority.P2_HIGH)
          
          # Phase 1: Investigation
          print("\nüîç Phase 1: Investigation")
          investigator = self.deploy_agent(
              task_id,
              "investigator",
              f"Investigate the root cause of: {description}"
          )
          
          # Wait for investigation
          self._wait_for_agent_completion(task_id, investigator, timeout=900)
          
          # Read findings
          findings = self._read_findings(task_id)
          
          # Phase 2: Implementation
          print("\nüîß Phase 2: Implementation")
          if "database" in str(findings).lower():
              fixer_type = "database_specialist"
          elif "performance" in str(findings).lower():
              fixer_type = "performance_optimizer"
          else:
              fixer_type = "general_fixer"
          
          fixer = self.deploy_agent(
              task_id,
              fixer_type,
              f"Fix the issues found: {findings}"
          )
          
          # Wait for fix
          self._wait_for_agent_completion(task_id, fixer, timeout=1200)
          
          # Phase 3: Review
          print("\n‚úÖ Phase 3: Review")
          reviewer = self.deploy_agent(
              task_id,
              "quality_reviewer",
              f"Review the fixes implemented by {fixer}"
          )
          
          # Wait for review
          self._wait_for_agent_completion(task_id, reviewer, timeout=600)
          
          # Generate report
          self._generate_report(task_id)
          
          return task_id
      
      def orchestrate_parallel_analysis(self, description: str, aspects: List[str]) -> str:
          """
          Deploy multiple analysts in parallel
          """
          task_id = self.create_task(description, Priority.P1_CRITICAL)
          
          print(f"\nüîÄ Deploying {len(aspects)} parallel analysts")
          
          agents = []
          for aspect in aspects:
              agent_id = self.deploy_agent(
                  task_id,
                  f"{aspect}_analyst",
                  f"Analyze {aspect} aspect of: {description}"
              )
              if agent_id:
                  agents.append(agent_id)
              time.sleep(2)  # Stagger deployments
          
          # Wait for all to complete
          for agent_id in agents:
              self._wait_for_agent_completion(task_id, agent_id, timeout=900)
          
          # Deploy synthesizer
          print("\nüîÑ Deploying synthesizer")
          synthesizer = self.deploy_agent(
              task_id,
              "synthesizer",
              "Synthesize findings from all analysts into coherent solution"
          )
          
          self._wait_for_agent_completion(task_id, synthesizer, timeout=600)
          
          return task_id
      
      def orchestrate_iterative_improvement(self, 
                                          description: str, 
                                          max_iterations: int = 3) -> str:
          """
          Iterative improvement pattern with quality gates
          """
          task_id = self.create_task(description, Priority.P2_HIGH)
          
          quality_threshold = 80
          current_quality = 0
          iteration = 0
          
          while current_quality < quality_threshold and iteration < max_iterations:
              iteration += 1
              print(f"\nüîÑ Iteration {iteration}/{max_iterations}")
              
              # Deploy implementer
              implementer = self.deploy_agent(
                  task_id,
                  f"implementer_v{iteration}",
                  f"Implement/improve solution for: {description} (iteration {iteration})"
              )
              
              self._wait_for_agent_completion(task_id, implementer, timeout=900)
              
              # Check quality
              quality = self._check_quality(task_id)
              current_quality = quality['score']
              
              print(f"   Quality Score: {current_quality}%")
              
              if current_quality < quality_threshold:
                  # Deploy improver
                  feedback = quality.get('feedback', 'Needs improvement')
                  improver = self.deploy_agent(
                      task_id,
                      f"improver_v{iteration}",
                      f"Improve based on feedback: {feedback}"
                  )
                  self._wait_for_agent_completion(task_id, improver, timeout=600)
          
          if current_quality >= quality_threshold:
              print(f"‚úÖ Quality threshold met: {current_quality}%")
          else:
              print(f"‚ö†Ô∏è Max iterations reached. Final quality: {current_quality}%")
          
          return task_id
      
      # ========================================
      # HELPER METHODS
      # ========================================
      
      def _wait_for_agent_completion(self, 
                                     task_id: str, 
                                     agent_id: str, 
                                     timeout: int = 600):
          """Wait for agent to complete with timeout"""
          start = time.time()
          
          while time.time() - start < timeout:
              output, _ = self._run_command(f"agent-ctl status '{task_id}'")
              
              if f"{agent_id}" in output and "100%" in output:
                  print(f"‚úÖ {agent_id} completed")
                  return True
              
              time.sleep(30)
          
          print(f"‚è±Ô∏è Timeout waiting for {agent_id}")
          return False
      
      def _read_findings(self, task_id: str) -> dict:
          """Read findings from workspace"""
          task = self.active_tasks[task_id]
          findings = {}
          
          findings_dir = f"{task.workspace}/findings"
          if os.path.exists(findings_dir):
              for file in os.listdir(findings_dir):
                  if file.endswith('.json'):
                      with open(f"{findings_dir}/{file}", 'r') as f:
                          data = json.load(f)
                          findings[data['key']] = data['value']
          
          return findings
      
      def _check_quality(self, task_id: str) -> dict:
          """Run quality check"""
          output, _ = self._run_command(
              f"cd {self.active_tasks[task_id].workspace} && check-quality"
          )
          
          # Parse quality score
          score_match = re.search(r"Quality Score: (\d+)%", output)
          score = int(score_match.group(1)) if score_match else 0
          
          return {
              'score': score,
              'output': output,
              'feedback': "Improve test coverage and documentation" if score < 80 else "Good"
          }
      
      def _generate_report(self, task_id: str):
          """Generate final report"""
          print("\nüìä Generating report...")
          output, _ = self._run_command(f"agent-ctl report '{task_id}' detailed")
          print(output)
      
      def get_task_status(self, task_id: str) -> dict:
          """Get current task status"""
          output, _ = self._run_command(f"agent-ctl status '{task_id}' true")
          return {'raw': output}
      
      def kill_all_agents(self, task_id: str):
          """Emergency kill all agents for a task"""
          print(f"üõë Killing all agents for {task_id}")
          
          registry_path = f"{self.active_tasks[task_id].workspace}/AGENT_REGISTRY.json"
          with open(registry_path, 'r') as f:
              registry = json.load(f)
          
          for agent in registry['agents']:
              if agent['status'] == 'running':
                  self._run_command(
                      f"agent-ctl kill '{task_id}' '{agent['id']}' 'Emergency shutdown'"
                  )

  # ============================================================================
  # USAGE EXAMPLES
  # ============================================================================

  def main():
      """
      Example usage of the orchestrator
      """
      orchestrator = AgentOrchestrator()
      
      # Example 1: Simple investigation and fix
      print("=" * 60)
      print("EXAMPLE 1: Investigation ‚Üí Fix ‚Üí Review Pattern")
      print("=" * 60)
      
      task_id = orchestrator.orchestrate_investigation_fix_pattern(
          "Users reporting empty measurement screen despite data in database"
      )
      
      print(f"\n‚úÖ Task {task_id} completed")
      print(orchestrator.get_task_status(task_id)['raw'])
      
      # Example 2: Parallel analysis
      print("\n" + "=" * 60)
      print("EXAMPLE 2: Parallel Analysis Pattern")
      print("=" * 60)
      
      task_id = orchestrator.orchestrate_parallel_analysis(
          "Optimize application performance",
          aspects=["database", "frontend", "api", "caching"]
      )
      
      # Example 3: Iterative improvement
      print("\n" + "=" * 60)
      print("EXAMPLE 3: Iterative Improvement Pattern")
      print("=" * 60)
      
      task_id = orchestrator.orchestrate_iterative_improvement(
          "Refactor authentication system for better security",
          max_iterations=3
      )
      
      # Example 4: Manual control
      print("\n" + "=" * 60)
      print("EXAMPLE 4: Manual Agent Control")
      print("=" * 60)
      
      # Create task
      task_id = orchestrator.create_task("Fix performance regression in search", Priority.P1_CRITICAL)
      
      # Deploy specific agents
      profiler = orchestrator.deploy_agent(
          task_id,
          "performance_profiler",
          "Profile the search functionality and identify bottlenecks"
      )
      
      # Monitor in real-time
      for _ in range(10):
          print(orchestrator.get_task_status(task_id)['raw'])
          time.sleep(30)
      
      # Deploy optimizer based on findings
      optimizer = orchestrator.deploy_agent(
          task_id,
          "query_optimizer",
          "Optimize the slow queries identified by profiler",
          parent=profiler  # Set parent for hierarchy
      )
      
      # If things go wrong, kill all
      # orchestrator.kill_all_agents(task_id)

  if __name__ == "__main__":
      main()[O    /  #!/bin/bash

  # ============================================================================
  # AGENT ORCHESTRATION TOOLKIT
  # A comprehensive set of CLI tools for agent management
  # ============================================================================

  # Configuration
  AGENT_BASE_DIR="${AGENT_BASE_DIR:-.agent-workspace}"
  SCRIPTS_DIR="${AGENT_BASE_DIR}/scripts"
  REGISTRY_FILE="AGENT_REGISTRY.json"
  MAX_AGENTS=10
  MAX_DEPTH=3

  # ============================================================================
  # INSTALLATION SCRIPT
  # ============================================================================

  cat << 'INSTALL_SCRIPT' > setup_agent_toolkit.sh
  #!/bin/bash

  echo "üöÄ Installing Agent Orchestration Toolkit..."

  # Create base directories
  mkdir -p .agent-workspace/{scripts,templates,bin}

  # Create the main orchestrator command
  cat << 'MAIN_CMD' > .agent-workspace/bin/agent-ctl
  #!/bin/bash
  AGENT_BASE_DIR=".agent-workspace"
  COMMAND=$1
  shift

  case $COMMAND in
      init|deploy|status|update|monitor|kill|review|report)
          $AGENT_BASE_DIR/scripts/${COMMAND}.sh "$@"
          ;;
      *)
          echo "Usage: agent-ctl {init|deploy|status|update|monitor|kill|review|report} [options]"
          exit 1
          ;;
  esac
  MAIN_CMD

  chmod +x .agent-workspace/bin/agent-ctl

  # Add to PATH for current session
  export PATH="$PWD/.agent-workspace/bin:$PATH"
  echo 'export PATH="$PWD/.agent-workspace/bin:$PATH"' >> ~/.bashrc

  echo "‚úÖ Toolkit installed! Commands available:"
  echo "   agent-ctl init    - Initialize new task workspace"
  echo "   agent-ctl deploy  - Deploy new agent"
  echo "   agent-ctl status  - Check agent status"
  echo "   agent-ctl update  - Update agent progress"
  echo "   agent-ctl monitor - Monitor all agents"
  echo "   agent-ctl kill    - Terminate agent"
  echo "   agent-ctl review  - Request peer review"
  echo "   agent-ctl report  - Generate reports"
  INSTALL_SCRIPT

  # ============================================================================
  # CORE SCRIPTS
  # ============================================================================

  # ------------------------------------
  # 1. INIT SCRIPT - Initialize Workspace
  # ------------------------------------
  cat << 'INIT_SCRIPT' > ${SCRIPTS_DIR}/init.sh
  #!/bin/bash

  TASK_DESC="${1:-No description provided}"
  PRIORITY="${2:-P2}"
  REQUESTER="${3:-user}"

  # Generate IDs
  TASK_ID="TASK-$(date +%Y%m%d-%H%M%S)-$(uuidgen | cut -c1-8)"
  WORKSPACE="${AGENT_BASE_DIR}/${TASK_ID}"

  echo "üìÇ Initializing workspace for task: ${TASK_ID}"

  # Create directory structure
  mkdir -p "${WORKSPACE}"/{context,progress,handoffs,tickets,reviews,rollbacks,knowledge,metrics,escalations,standups}

  # Initialize Agent Registry
  cat << EOF > "${WORKSPACE}/${REGISTRY_FILE}"
  {
    "task_id": "${TASK_ID}",
    "task_description": "${TASK_DESC}",
    "created_at": "$(date -Iseconds)",
    "workspace": "${WORKSPACE}",
    "status": "INITIALIZED",
    "agents": [],
    "max_agents": ${MAX_AGENTS},
    "max_depth": ${MAX_DEPTH},
    "total_spawned": 0,
    "active_count": 0,
    "completed_count": 0,
    "failed_count": 0
  }
  EOF

  # Initialize Spawn Rules
  cat << 'EOF' > "${WORKSPACE}/SPAWN_RULES.json"
  {
    "orchestrator": ["investigator", "implementer", "reviewer", "performance_doctor"],
    "investigator": ["deep_analyzer"],
    "implementer": ["code_writer", "test_writer"],
    "reviewer": [],
    "performance_doctor": ["profiler"],
    "deep_analyzer": [],
    "code_writer": [],
    "test_writer": [],
    "profiler": []
  }
  EOF

  # Create main ticket
  TICKET_ID="TKT-${TASK_ID:5:20}"
  cat << EOF > "${WORKSPACE}/tickets/${TICKET_ID}.json"
  {
    "ticket_id": "${TICKET_ID}",
    "task_id": "${TASK_ID}",
    "title": "${TASK_DESC}",
    "priority": "${PRIORITY}",
    "requester": "${REQUESTER}",
    "created_at": "$(date -Iseconds)",
    "status": "OPEN",
    "assigned_to": null,
    "deadline": "$(date -Iseconds -d '+2 hours')",
    "acceptance_criteria": [],
    "progress_updates": []
  }
  EOF

  # Create baseline metrics
  cat << EOF > "${WORKSPACE}/metrics/baseline.json"
  {
    "captured_at": "$(date -Iseconds)",
    "performance_ms": null,
    "memory_mb": null,
    "test_pass_rate": null,
    "error_rate": null
  }
  EOF

  # Output workspace info
  echo "‚úÖ Workspace initialized!"
  echo "   Task ID: ${TASK_ID}"
  echo "   Workspace: ${WORKSPACE}"
  echo "   Ticket: ${TICKET_ID}"
  echo ""
  echo "Next step: agent-ctl deploy <agent_type> \"${TASK_ID}\" \"<task_description>\""

  # Return task ID for scripting
  echo "TASK_ID=${TASK_ID}" > "${WORKSPACE}/.env"
  echo "${TASK_ID}"
  INIT_SCRIPT

  # ------------------------------------
  # 2. DEPLOY SCRIPT - Deploy New Agent
  # ------------------------------------
  cat << 'DEPLOY_SCRIPT' > ${SCRIPTS_DIR}/deploy.sh
  #!/bin/bash

  AGENT_TYPE="${1:?Error: Agent type required}"
  TASK_ID="${2:?Error: Task ID required}"
  TASK_PROMPT="${3:?Error: Task prompt required}"
  PARENT_AGENT="${4:-orchestrator}"

  WORKSPACE="${AGENT_BASE_DIR}/${TASK_ID}"
  REGISTRY="${WORKSPACE}/${REGISTRY_FILE}"

  # Validate workspace exists
  if [ ! -f "${REGISTRY}" ]; then
      echo "‚ùå Error: Task ${TASK_ID} not found. Run 'agent-ctl init' first."
      exit 1
  fi

  # Read registry
  REGISTRY_DATA=$(cat "${REGISTRY}")
  TOTAL_SPAWNED=$(echo "${REGISTRY_DATA}" | jq -r '.total_spawned')
  ACTIVE_COUNT=$(echo "${REGISTRY_DATA}" | jq -r '.active_count')
  MAX_AGENTS=$(echo "${REGISTRY_DATA}" | jq -r '.max_agents')

  # Check limits
  if [ "${TOTAL_SPAWNED}" -ge "${MAX_AGENTS}" ]; then
      echo "‚ùå Max agents (${MAX_AGENTS}) reached. Cannot deploy ${AGENT_TYPE}"
      exit 1
  fi

  if [ "${ACTIVE_COUNT}" -ge 5 ]; then
      echo "‚ö†Ô∏è  Warning: ${ACTIVE_COUNT} agents already active. Consider waiting."
  fi

  # Check spawn rules
  SPAWN_RULES=$(cat "${WORKSPACE}/SPAWN_RULES.json")
  ALLOWED=$(echo "${SPAWN_RULES}" | jq -r ".${PARENT_AGENT}[]" 2>/dev/null | grep -c "^${AGENT_TYPE}$")

  if [ "${ALLOWED}" -eq 0 ] && [ "${PARENT_AGENT}" != "orchestrator" ]; then
      echo "‚ùå ${PARENT_AGENT} cannot spawn ${AGENT_TYPE}"
      exit 1
  fi

  # Generate agent ID
  AGENT_ID="${AGENT_TYPE}-$(date +%H%M%S)-$(uuidgen | cut -c1-6)"

  echo "ü§ñ Deploying agent: ${AGENT_ID}"

  # Create agent prompt with toolkit commands
  AGENT_PROMPT="
  ü§ñ AGENT: ${AGENT_TYPE}
  üÜî ID: ${AGENT_ID}
  üìã TASK: ${TASK_ID}
  üìÅ WORKSPACE: ${WORKSPACE}

  AVAILABLE COMMANDS:
  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  ‚Ä¢ update-progress <percent> <message>  - Update your progress
  ‚Ä¢ request-review <file_path>           - Request code review
  ‚Ä¢ escalate <issue>                      - Escalate a blocker
  ‚Ä¢ read-context                         - Read task context
  ‚Ä¢ write-finding <key> <value>          - Document findings
  ‚Ä¢ check-quality                        - Run quality checks
  ‚Ä¢ create-rollback                      - Create rollback point

  YOUR TASK:
  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  ${TASK_PROMPT}

  EXECUTION PROTOCOL:
  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  1. Start by reading context:
     read-context

  2. Update progress every 2-3 minutes:
     update-progress 25 \"Analyzing database queries\"

  3. Document findings:
     write-finding \"root_cause\" \"N+1 query in measurements controller\"

  4. If stuck, escalate:
     escalate \"Cannot access production database\"

  5. When complete:
     update-progress 100 \"Task completed successfully\"
  "

  # Deploy agent via Claude
  BASH_ID=$(claude --dangerously-skip-permissions \
      --output-format stream-json \
      --verbose \
      -p "${AGENT_PROMPT}" \
      --run-in-background 2>&1 | grep -oP 'bash_\w+' | head -1)

  # Update registry
  REGISTRY_UPDATE=$(echo "${REGISTRY_DATA}" | jq \
      --arg agent_id "${AGENT_ID}" \
      --arg agent_type "${AGENT_TYPE}" \
      --arg bash_id "${BASH_ID}" \
      --arg parent "${PARENT_AGENT}" \
      --arg started_at "$(date -Iseconds)" \
      '.agents += [{
          "id": $agent_id,
          "type": $agent_type,
          "bash_id": $bash_id,
          "parent": $parent,
          "status": "running",
          "started_at": $started_at,
          "progress": 0,
          "last_update": $started_at
      }] |
      .total_spawned += 1 |
      .active_count += 1')

  echo "${REGISTRY_UPDATE}" > "${REGISTRY}"

  echo "‚úÖ Agent deployed!"
  echo "   Agent ID: ${AGENT_ID}"
  echo "   Bash ID: ${BASH_ID}"
  echo "   Type: ${AGENT_TYPE}"
  echo ""
  echo "Monitor with: agent-ctl status ${TASK_ID}"

  # Return agent ID
  echo "${AGENT_ID}"
  DEPLOY_SCRIPT

  # ------------------------------------
  # 3. UPDATE SCRIPT - Update Agent Progress
  # ------------------------------------
  cat << 'UPDATE_SCRIPT' > ${SCRIPTS_DIR}/update.sh
  #!/bin/bash

  # This script is called BY agents to update their progress

  AGENT_ID="${1:?Error: Agent ID required}"
  PROGRESS="${2:?Error: Progress percentage required}"
  MESSAGE="${3:-No message}"
  TASK_ID="${4}"

  # Find workspace by agent ID if task not provided
  if [ -z "${TASK_ID}" ]; then
      WORKSPACE=$(find "${AGENT_BASE_DIR}" -name "${REGISTRY_FILE}" -exec grep -l "${AGENT_ID}" {} \; | head -1 | xargs dirname)
  else
      WORKSPACE="${AGENT_BASE_DIR}/${TASK_ID}"
  fi

  if [ -z "${WORKSPACE}" ] || [ ! -d "${WORKSPACE}" ]; then
      echo "‚ùå Error: Cannot find workspace for agent ${AGENT_ID}"
      exit 1
  fi

  # Create progress update
  PROGRESS_FILE="${WORKSPACE}/progress/${AGENT_ID}_$(date +%s).json"
  cat << EOF > "${PROGRESS_FILE}"
  {
    "agent_id": "${AGENT_ID}",
    "timestamp": "$(date -Iseconds)",
    "progress": ${PROGRESS},
    "message": "${MESSAGE}",
    "memory_usage_mb": $(ps aux | grep "${AGENT_ID}" | awk '{sum+=$6} END {print sum/1024}' 2>/dev/null || echo 0),
    "status": $([ "${PROGRESS}" -eq 100 ] && echo '"completed"' || echo '"in_progress"')
  }
  EOF

  # Update registry
  REGISTRY="${WORKSPACE}/${REGISTRY_FILE}"
  REGISTRY_DATA=$(cat "${REGISTRY}")
  UPDATED_REGISTRY=$(echo "${REGISTRY_DATA}" | jq \
      --arg agent_id "${AGENT_ID}" \
      --arg progress "${PROGRESS}" \
      --arg last_update "$(date -Iseconds)" \
      --arg status $([ "${PROGRESS}" -eq 100 ] && echo "completed" || echo "running") \
      '(.agents[] | select(.id == $agent_id)) |= (
          .progress = ($progress | tonumber) |
          .last_update = $last_update |
          .status = $status
      ) |
      if $status == "completed" then
          .active_count -= 1 |
          .completed_count += 1
      else . end')

  echo "${UPDATED_REGISTRY}" > "${REGISTRY}"

  echo "‚úÖ Progress updated: ${PROGRESS}% - ${MESSAGE}"

  # Check for completion
  if [ "${PROGRESS}" -eq 100 ]; then
      echo "üéâ Agent ${AGENT_ID} completed!"
      
      # Trigger any pending reviews
      if [ -f "${WORKSPACE}/handoffs/needs_review_${AGENT_ID}.flag" ]; then
          agent-ctl review "${TASK_ID}" "${AGENT_ID}"
      fi
  fi
  UPDATE_SCRIPT

  # ------------------------------------
  # 4. STATUS SCRIPT - Check Status
  # ------------------------------------
  cat << 'STATUS_SCRIPT' > ${SCRIPTS_DIR}/status.sh
  #!/bin/bash

  TASK_ID="${1:?Error: Task ID required}"
  DETAILED="${2:-false}"

  WORKSPACE="${AGENT_BASE_DIR}/${TASK_ID}"
  REGISTRY="${WORKSPACE}/${REGISTRY_FILE}"

  if [ ! -f "${REGISTRY}" ]; then
      echo "‚ùå Error: Task ${TASK_ID} not found"
      exit 1
  fi

  # Read registry
  REGISTRY_DATA=$(cat "${REGISTRY}")

  # Display summary
  echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
  echo "üìä TASK STATUS: ${TASK_ID}"
  echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
  echo ""
  echo "Task: $(echo "${REGISTRY_DATA}" | jq -r '.task_description')"
  echo "Created: $(echo "${REGISTRY_DATA}" | jq -r '.created_at')"
  echo "Status: $(echo "${REGISTRY_DATA}" | jq -r '.status')"
  echo ""
  echo "AGENTS:"
  echo "‚îú‚îÄ Total Spawned: $(echo "${REGISTRY_DATA}" | jq -r '.total_spawned')"
  echo "‚îú‚îÄ Currently Active: $(echo "${REGISTRY_DATA}" | jq -r '.active_count')"
  echo "‚îú‚îÄ Completed: $(echo "${REGISTRY_DATA}" | jq -r '.completed_count')"
  echo "‚îî‚îÄ Failed: $(echo "${REGISTRY_DATA}" | jq -r '.failed_count')"
  echo ""

  # Show agent details
  echo "ACTIVE AGENTS:"
  echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
  echo "${REGISTRY_DATA}" | jq -r '.agents[] | select(.status == "running") | 
      "‚Ä¢ \(.id)\n  Type: \(.type) | Progress: \(.progress)% | Last Update: \(.last_update)"'

  if [ "${DETAILED}" == "true" ]; then
      echo ""
      echo "RECENT PROGRESS UPDATES:"
      echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
      ls -t "${WORKSPACE}"/progress/*.json 2>/dev/null | head -5 | while read -r file; do
          jq -r '"‚Ä¢ [\(.timestamp)] \(.agent_id): \(.progress)% - \(.message)"' "$file"
      done
      
      echo ""
      echo "ESCALATIONS:"
      echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
      ls "${WORKSPACE}"/escalations/*.json 2>/dev/null | while read -r file; do
          jq -r '"‚ö†Ô∏è  \(.agent_id): \(.issue)"' "$file"
      done
  fi

  echo ""
  echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
  STATUS_SCRIPT

  # ------------------------------------
  # 5. MONITOR SCRIPT - Active Monitoring
  # ------------------------------------
  cat << 'MONITOR_SCRIPT' > ${SCRIPTS_DIR}/monitor.sh
  #!/bin/bash

  TASK_ID="${1:?Error: Task ID required}"
  INTERVAL="${2:-30}"

  WORKSPACE="${AGENT_BASE_DIR}/${TASK_ID}"
  REGISTRY="${WORKSPACE}/${REGISTRY_FILE}"

  echo "üëÅÔ∏è  Starting monitor for ${TASK_ID} (interval: ${INTERVAL}s)"
  echo "Press Ctrl+C to stop monitoring"
  echo ""

  # Monitoring loop
  while true; do
      clear
      
      # Show status
      agent-ctl status "${TASK_ID}" true
      
      # Check for issues
      REGISTRY_DATA=$(cat "${REGISTRY}")
      ACTIVE_COUNT=$(echo "${REGISTRY_DATA}" | jq -r '.active_count')
      
      # Check for stuck agents (no update in 5 minutes)
      CURRENT_TIME=$(date +%s)
      echo "${REGISTRY_DATA}" | jq -r '.agents[] | select(.status == "running") | "\(.id)|\(.last_update)"' | while IFS='|' read -r agent_id last_update; do
          LAST_UPDATE_TIME=$(date -d "${last_update}" +%s 2>/dev/null || echo 0)
          TIME_DIFF=$((CURRENT_TIME - LAST_UPDATE_TIME))
          
          if [ ${TIME_DIFF} -gt 300 ]; then
              echo "‚ö†Ô∏è  WARNING: ${agent_id} hasn't updated in $((TIME_DIFF/60)) minutes"
              
              # Auto-escalate if stuck too long
              if [ ${TIME_DIFF} -gt 600 ]; then
                  echo "üö® AUTO-ESCALATING: ${agent_id} stuck for >10 minutes"
                  agent-ctl escalate "${TASK_ID}" "${agent_id}" "Agent unresponsive"
              fi
          fi
      done
      
      # Check for spiral condition
      if [ ${ACTIVE_COUNT} -gt 5 ]; then
          echo ""
          echo "üö® SPIRAL WARNING: ${ACTIVE_COUNT} agents active simultaneously!"
          echo "Consider killing some agents: agent-ctl kill ${TASK_ID} <agent_id>"
      fi
      
      sleep "${INTERVAL}"
  done
  MONITOR_SCRIPT

  # ------------------------------------
  # 6. KILL SCRIPT - Terminate Agent
  # ------------------------------------
  cat << 'KILL_SCRIPT' > ${SCRIPTS_DIR}/kill.sh
  #!/bin/bash

  TASK_ID="${1:?Error: Task ID required}"
  AGENT_ID="${2:?Error: Agent ID required}"
  REASON="${3:-Manual termination}"

  WORKSPACE="${AGENT_BASE_DIR}/${TASK_ID}"
  REGISTRY="${WORKSPACE}/${REGISTRY_FILE}"

  # Get bash ID from registry
  BASH_ID=$(jq -r --arg id "${AGENT_ID}" '.agents[] | select(.id == $id) | .bash_id' "${REGISTRY}")

  if [ -z "${BASH_ID}" ]; then
      echo "‚ùå Error: Agent ${AGENT_ID} not found"
      exit 1
  fi

  echo "üõë Terminating agent ${AGENT_ID} (${BASH_ID})"

  # Kill the bash process
  kill -9 $(ps aux | grep "${BASH_ID}" | grep -v grep | awk '{print $2}') 2>/dev/null || true

  # Update registry
  REGISTRY_DATA=$(cat "${REGISTRY}")
  UPDATED_REGISTRY=$(echo "${REGISTRY_DATA}" | jq \
      --arg agent_id "${AGENT_ID}" \
      --arg terminated_at "$(date -Iseconds)" \
      --arg reason "${REASON}" \
      '(.agents[] | select(.id == $agent_id)) |= (
          .status = "terminated" |
          .terminated_at = $terminated_at |
          .termination_reason = $reason
      ) |
      .active_count -= 1 |
      .failed_count += 1')

  echo "${UPDATED_REGISTRY}" > "${REGISTRY}"

  # Log termination
  cat << EOF > "${WORKSPACE}/escalations/terminated_${AGENT_ID}.json"
  {
    "agent_id": "${AGENT_ID}",
    "bash_id": "${BASH_ID}",
    "terminated_at": "$(date -Iseconds)",
    "reason": "${REASON}"
  }
  EOF

  echo "‚úÖ Agent ${AGENT_ID} terminated"
  KILL_SCRIPT

  # ------------------------------------
  # 7. REVIEW SCRIPT - Request Review
  # ------------------------------------
  cat << 'REVIEW_SCRIPT' > ${SCRIPTS_DIR}/review.sh
  #!/bin/bash

  TASK_ID="${1:?Error: Task ID required}"
  AGENT_ID="${2:?Error: Agent ID to review required}"
  REVIEWER_TYPE="${3:-reviewer}"

  WORKSPACE="${AGENT_BASE_DIR}/${TASK_ID}"

  echo "üìã Requesting review for ${AGENT_ID}'s work"

  # Create review request
  REVIEW_ID="REV-$(date +%H%M%S)"
  cat << EOF > "${WORKSPACE}/reviews/request_${REVIEW_ID}.json"
  {
    "review_id": "${REVIEW_ID}",
    "task_id": "${TASK_ID}",
    "agent_to_review": "${AGENT_ID}",
    "requested_at": "$(date -Iseconds)",
    "status": "pending",
    "reviewer": null
  }
  EOF

  # Deploy reviewer agent
  REVIEW_PROMPT="Review the work completed by ${AGENT_ID} in task ${TASK_ID}. 
  Check for quality, completeness, and potential issues.
  Write your review to: ${WORKSPACE}/reviews/review_${REVIEW_ID}.json"

  REVIEWER_ID=$(agent-ctl deploy "${REVIEWER_TYPE}" "${TASK_ID}" "${REVIEW_PROMPT}")

  # Update review request with reviewer
  jq --arg reviewer "${REVIEWER_ID}" '.reviewer = $reviewer | .status = "in_progress"' \
      "${WORKSPACE}/reviews/request_${REVIEW_ID}.json" > "${WORKSPACE}/reviews/request_${REVIEW_ID}.tmp"
  mv "${WORKSPACE}/reviews/request_${REVIEW_ID}.tmp" "${WORKSPACE}/reviews/request_${REVIEW_ID}.json"

  echo "‚úÖ Review requested"
  echo "   Review ID: ${REVIEW_ID}"
  echo "   Reviewer: ${REVIEWER_ID}"
  REVIEW_SCRIPT

  # ------------------------------------
  # 8. REPORT SCRIPT - Generate Reports
  # ------------------------------------
  cat << 'REPORT_SCRIPT' > ${SCRIPTS_DIR}/report.sh
  #!/bin/bash

  TASK_ID="${1:?Error: Task ID required}"
  REPORT_TYPE="${2:-summary}"  # summary, detailed, metrics

  WORKSPACE="${AGENT_BASE_DIR}/${TASK_ID}"
  REGISTRY="${WORKSPACE}/${REGISTRY_FILE}"

  echo "üìä Generating ${REPORT_TYPE} report for ${TASK_ID}"

  REGISTRY_DATA=$(cat "${REGISTRY}")
  REPORT_FILE="${WORKSPACE}/reports/report_$(date +%Y%m%d_%H%M%S).json"
  mkdir -p "${WORKSPACE}/reports"

  case ${REPORT_TYPE} in
      summary)
          cat << EOF > "${REPORT_FILE}"
  {
    "task_id": "${TASK_ID}",
    "generated_at": "$(date -Iseconds)",
    "type": "summary",
    "task_description": $(echo "${REGISTRY_DATA}" | jq '.task_description'),
    "status": $(echo "${REGISTRY_DATA}" | jq '.status'),
    "metrics": {
      "total_agents": $(echo "${REGISTRY_DATA}" | jq '.total_spawned'),
      "completed": $(echo "${REGISTRY_DATA}" | jq '.completed_count'),
      "failed": $(echo "${REGISTRY_DATA}" | jq '.failed_count'),
      "duration_minutes": $(( ($(date +%s) - $(date -d "$(echo "${REGISTRY_DATA}" | jq -r '.created_at')" +%s)) / 60 ))
    },
    "success_rate": $(echo "${REGISTRY_DATA}" | jq '(.completed_count / .total_spawned * 100) | floor')
  }
  EOF
          ;;
          
      detailed)
          # Gather all data
          PROGRESS_COUNT=$(ls "${WORKSPACE}"/progress/*.json 2>/dev/null | wc -l)
          ESCALATION_COUNT=$(ls "${WORKSPACE}"/escalations/*.json 2>/dev/null | wc -l)
          REVIEW_COUNT=$(ls "${WORKSPACE}"/reviews/*.json 2>/dev/null | wc -l)
          
          cat << EOF > "${REPORT_FILE}"
  {
    "task_id": "${TASK_ID}",
    "generated_at": "$(date -Iseconds)",
    "type": "detailed",
    "registry": ${REGISTRY_DATA},
    "statistics": {
      "progress_updates": ${PROGRESS_COUNT},
      "escalations": ${ESCALATION_COUNT},
      "reviews": ${REVIEW_COUNT}
    },
    "timeline": [
      $(ls -t "${WORKSPACE}"/progress/*.json 2>/dev/null | while read -r file; do
          jq -c '{time: .timestamp, agent: .agent_id, progress: .progress, message: .message}' "$file"
      done | paste -sd,)
    ],
    "final_state": {
      "all_complete": $([ $(echo "${REGISTRY_DATA}" | jq '.active_count') -eq 0 ] && echo "true" || echo "false"),
      "has_failures": $([ $(echo "${REGISTRY_DATA}" | jq '.failed_count') -gt 0 ] && echo "true" || echo "false")
    }
  }
  EOF
          ;;
          
      metrics)
          # Performance metrics
          cat << EOF > "${REPORT_FILE}"
  {
    "task_id": "${TASK_ID}",
    "generated_at": "$(date -Iseconds)",
    "type": "metrics",
    "performance": {
      "avg_completion_time_minutes": $(
          ls "${WORKSPACE}"/progress/*_100_*.json 2>/dev/null | while read -r file; do
              jq -r '.timestamp' "$file"
          done | awk '{print $1}' | head -1 | xargs -I {} date -d {} +%s | awk -v start=$(date -d "$(echo "${REGISTRY_DATA}" | jq -r '.created_at')" +%s) '{print ($1-start)/60}'
      ),
      "parallel_efficiency": $(echo "${REGISTRY_DATA}" | jq '(.completed_count / (.total_spawned * 1.5) * 100) | floor'),
      "resource_usage": {
        "total_compute_minutes": $(( $(echo "${REGISTRY_DATA}" | jq '.total_spawned') * 5 )),
        "peak_concurrent_agents": 5
      }
    }
  }
  EOF
          ;;
  esac

  echo "‚úÖ Report generated: ${REPORT_FILE}"
  cat "${REPORT_FILE}" | jq '.'
  REPORT_SCRIPT

  # ------------------------------------
  # 9. HELPER COMMANDS for Agents
  # ------------------------------------

  # update-progress command for agents
  cat << 'HELPER_UPDATE_PROGRESS' > ${SCRIPTS_DIR}/update-progress
  #!/bin/bash
  # Simple wrapper for agents to call
  AGENT_ID="${AGENT_ID:-unknown}"
  agent-ctl update "${AGENT_ID}" "$@"
  HELPER_UPDATE_PROGRESS

  # escalate command for agents
  cat << 'HELPER_ESCALATE' > ${SCRIPTS_DIR}/escalate
  #!/bin/bash
  AGENT_ID="${AGENT_ID:-unknown}"
  ISSUE="${1:-Unknown issue}"
  WORKSPACE="${WORKSPACE:-.}"

  cat << EOF > "${WORKSPACE}/escalations/escalation_$(date +%s).json"
  {
    "agent_id": "${AGENT_ID}",
    "timestamp": "$(date -Iseconds)",
    "issue": "${ISSUE}",
    "status": "open"
  }
  EOF

  echo "üö® Escalation created: ${ISSUE}"
  HELPER_ESCALATE

  # write-finding command for agents
  cat << 'HELPER_WRITE_FINDING' > ${SCRIPTS_DIR}/write-finding
  #!/bin/bash
  KEY="${1:?Error: Key required}"
  VALUE="${2:?Error: Value required}"
  AGENT_ID="${AGENT_ID:-unknown}"
  WORKSPACE="${WORKSPACE:-.}"

  mkdir -p "${WORKSPACE}/findings"
  cat << EOF > "${WORKSPACE}/findings/${KEY}_${AGENT_ID}.json"
  {
    "key": "${KEY}",
    "value": "${VALUE}",
    "agent_id": "${AGENT_ID}",
    "timestamp": "$(date -Iseconds)"
  }
  EOF

  echo "‚úÖ Finding recorded: ${KEY}"
  HELPER_WRITE_FINDING

  # read-context command for agents
  cat << 'HELPER_READ_CONTEXT' > ${SCRIPTS_DIR}/read-context
  #!/bin/bash
  WORKSPACE="${WORKSPACE:-.}"

  echo "ÔøΩÔøΩ Reading task context..."
  echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"

  # Read ticket
  if ls "${WORKSPACE}"/tickets/*.json >/dev/null 2>&1; then
      echo "TICKET:"
      jq -r '.title, .acceptance_criteria[]' "${WORKSPACE}"/tickets/*.json | head -10
      echo ""
  fi

  # Read previous findings
  if ls "${WORKSPACE}"/findings/*.json >/dev/null 2>&1; then
      echo "PREVIOUS FINDINGS:"
      jq -r '"‚Ä¢ " + .key + ": " + .value' "${WORKSPACE}"/findings/*.json
      echo ""
  fi

  # Read knowledge base
  if ls "${WORKSPACE}"/knowledge/*.json >/dev/null 2>&1; then
      echo "RELEVANT KNOWLEDGE:"
      jq -r '.key_insights[]' "${WORKSPACE}"/knowledge/*.json | head -5
  fi

  echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
  HELPER_READ_CONTEXT

  # create-rollback command for agents
  cat << 'HELPER_CREATE_ROLLBACK' > ${SCRIPTS_DIR}/create-rollback
  #!/bin/bash
  AGENT_ID="${AGENT_ID:-unknown}"
  WORKSPACE="${WORKSPACE:-.}"
  DESCRIPTION="${1:-Checkpoint}"

  # Create git commit
  git add -A 2>/dev/null
  COMMIT=$(git commit -m "Rollback point: ${AGENT_ID} - ${DESCRIPTION}" 2>/dev/null | grep -oP '\[[\w\s]+ \K[\w]+' || echo "no-git")

  # Save rollback point
  cat << EOF > "${WORKSPACE}/rollbacks/rollback_${AGENT_ID}_$(date +%s).json"
  {
    "agent_id": "${AGENT_ID}",
    "commit": "${COMMIT}",
    "description": "${DESCRIPTION}",
    "timestamp": "$(date -Iseconds)"
  }
  EOF

  echo "‚úÖ Rollback point created: ${COMMIT}"
  HELPER_CREATE_ROLLBACK

  # check-quality command for agents
  cat << 'HELPER_CHECK_QUALITY' > ${SCRIPTS_DIR}/check-quality
  #!/bin/bash
  WORKSPACE="${WORKSPACE:-.}"

  echo "üîç Running quality checks..."

  CHECKS_PASSED=0
  TOTAL_CHECKS=4

  # Check 1: Tests passing
  if npm test >/dev/null 2>&1; then
      echo "‚úÖ Tests passing"
      ((CHECKS_PASSED++))
  else
      echo "‚ùå Tests failing"
  fi

  # Check 2: No syntax errors
  if find . -name "*.js" -o -name "*.py" | xargs -I {} sh -c 'node --check {} 2>/dev/null || python3 -m py_compile {} 2>/dev/null' ; then
      echo "‚úÖ No syntax errors"
      ((CHECKS_PASSED++))
  else
      echo "‚ùå Syntax errors found"
  fi

  # Check 3: Performance not degraded
  # (simplified check - would be more complex in reality)
  echo "‚úÖ Performance acceptable"
  ((CHECKS_PASSED++))

  # Check 4: Documentation exists
  if ls "${WORKSPACE}"/findings/*.json >/dev/null 2>&1; then
      echo "‚úÖ Documentation found"
      ((CHECKS_PASSED++))
  else
      echo "‚ùå No documentation"
  fi

  QUALITY_SCORE=$((CHECKS_PASSED * 100 / TOTAL_CHECKS))
  echo ""
  echo "Quality Score: ${QUALITY_SCORE}%"

  # Save quality report
  cat << EOF > "${WORKSPACE}/metrics/quality_$(date +%s).json"
  {
    "timestamp": "$(date -Iseconds)",
    "checks_passed": ${CHECKS_PASSED},
    "total_checks": ${TOTAL_CHECKS},
    "score": ${QUALITY_SCORE}
  }
  EOF

  [ ${QUALITY_SCORE} -ge 75 ]  # Return success if quality >= 75%
  HELPER_CHECK_QUALITY

  # Make all scripts executable
  chmod +x ${SCRIPTS_DIR}/*.sh
  chmod +x ${SCRIPTS_DIR}/update-progress
  chmod +x ${SCRIPTS_DIR}/escalate
  chmod +x ${SCRIPTS_DIR}/write-finding
  chmod +x ${SCRIPTS_DIR}/read-context
  chmod +x ${SCRIPTS_DIR}/create-rollback
  chmod +x ${SCRIPTS_DIR}/check-quality

  echo "‚úÖ Agent Orchestration Toolkit installed successfully!"
  echo ""
  echo "Available commands:"
  echo "  agent-ctl init <task_description>     - Initialize new task"
  echo "  agent-ctl deploy <type> <task_id> <prompt>  - Deploy agent"
  echo "  agent-ctl status <task_id>            - Check status"
  echo "  agent-ctl monitor <task_id>           - Live monitoring"
  echo "  agent-ctl kill <task_id> <agent_id>   - Terminate agent"
  echo "  agent-ctl review <task_id> <agent_id> - Request review"
  echo "  agent-ctl report <task_id> [type]     - Generate report"
  echo ""
  echo "Agent helper commands:"
  echo "  update-progress <percent> <message>   - Update progress"
  echo "  escalate <issue>                      - Escalate issue"
  echo "  write-finding <key> <value>           - Document finding"
  echo "  read-context                          - Read task context"
  echo "  create-rollback <description>         - Create rollback point"
  echo "  check-quality                         - Run quality checks"          //     help me create this claude code orchestrator cli tool. ultrathink
  ‚éø ¬†Interrupted by user

> /export 
  ‚éø ¬†Conversation copied to clipboard

